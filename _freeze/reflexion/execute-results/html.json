{
  "hash": "9255716ef26f4c98ec2510e56965bff4",
  "result": {
    "markdown": "---\ntbl-cap-location: bottom\n---\n\n# Reflexion {#sec-reflexion}\n\n## Reflexion zur Lerneinheit\n\n### Reflexion zu den Klassen und Beispielprogrammen\nDie in der Lerneinheit entwickelten Klassen sind ein Produkt meines eigenen Lernprozesses. Im Nachhinein würde ich einige Funktionen anders implementieren. Die im @sec-AADmitOperatorOverloading verwendete Methode, zuerst eine Funktion für die Operation zu definieren und damit den Operator zu überladen, ist insgesamt übersichtlicher, als die direkte Methode, die in @sec-SadImplementationOperatorOverloading verwendet wurde. \nDie grösste Herausforderung war die Klasse `FloatAad` aus Kapitel @sec-AADmitOperatorOverloading, obwohl ich hier auf die gut geschriebene Einführung von @sidsite2021 zurückgreifen konnte. Das Bedürfnis nach weiteren Funktionalitäten wie `getGradient` oder `getJacobian` ergab sich erst später in Anwendungen und mussten nachträglich ergänzt werden. Schwierigkeiten bereitete dabei oft das Zusammenspiel zwischen meiner eigenen Klasse und `numpy`, weil Funktionen wie `getDerivatives` auf das Attribut `y.derivatives` zugreifen, die ein `np.array` nicht besitzt. Hier den Überblick zu behalten war nicht immer einfach.\n\nBei der Darstellung der Theorie und den Programmen legte ich den Fokus auf das Verständnis der Methode und nicht auf eine effiziente Implementierung. Die Auswertung der Ableitung geschieht zwar effizient, auch in der AAD Methode, allerdings werden dabei viele Hilfsvariablen angelegt. Die dafür benötigten Speicherzugriffe sind nehmen dabei mehr Zeit in Anspruch, als die eigentliche Berechnung (@Griewank2008EDP, S. 61). AD-Implementationen in modernen Programmiersprachen wie Julia versuchen, diese Probleme zu verhindern (@Baydin18, S. 22).\n\nBei der gezeigten Implementation der AAD in @sec-AADmitOperatorOverloading stösst man schnell an Grenzen, weil durch den rekursiven Aufruf von `computeDerivatives` die maximale Rekursionstiefe überschritten wird. Dies merkt man am deutlichsten am Beispiel des Schärfens von Bildern in @sec-deblurringImages. Dort musste die Auflösung des Bildes auf 30 $\\times$ 30 Pixel reduziert und die Farbinformation entfernt werden. Abhilfe könnte hier die Überladung der `numpy`-Operatoren bieten, so dass Arrays bestehend aus `FloatAad`-Objekten miteinander verknüpft werden können, ohne die einzelnen Elemente zu entpacken. \n\n\n\n### Was noch fehlt\nHier gäbe es noch ganz viel zu sagen. Das zeigt allein die Tatsache, dass jedes Buch der im Vorwort erwähnten Standardliteratur mehrere hundert Seiten dick ist. Eine Frage, die sich früher oder später den Schüler:innen stellen wird ist, ob man auch die zweite oder höhere Ableitungen mit AD-Methoden berechnen kann. Die kurze Antwort lautet: Ja! Wir beschränken uns an dieser Stelle aber auf ein Zitat aus @Naumann2012TAo (S. 91):\n> Forward and reverse modeAD transform implementations of multivariate vector functions into tangent-linear and adjoint code. The reapplication of the same ideas yields higher derivative code. Second- and higher-order tangent-linear code is obtained by recursive application of forward mode AD. Sequences of applications of forward and reverse mode that involve at least one application of reverse mode result in higher-order adjoint code. An exponential number of combinations can be considered, for example, fourth-order adjoint code generated in forward-over-reverse-over-forward-over-reverse mode.\n\n\n\n\n## Reflexion zum Einsatz im Unterricht\n\n### Voraussetzungen für die einzelnen Kapitel\n\nZu Beginn der Lerneinheit in @sec-AbleitungenUndAnwendungen sollten Schüler:innen die Ableitungen aller Grundfunktionen und die Ableitungsregeln kennen. Diese werden im @sec-AbleitungenUebersicht nochmals kurz zusammengefasst. Die hyperbolischen Funktionen werden der vollständigkeit halber ebenfalls erwähnt, im Rest der Arbeit werden sie aber nicht verwendet. In @sec-NumerischeVerfahren werden das Newtonverfahren und die Gradient Descent Methode kurz eingeführt, es macht aber Sinn, diese Verfahren vorher im Unterricht ausführlicher zu behandeln. Alternativ kann dieser Abschnitt auch weggelassen werden. \nAus dem Programmierunterricht sollte das Konzept einer Funktion mit Rückgabewert und die Verwendung von Bibliotheken bekannt sein. Im @sec-NumerischeVerfahren wird ausserdem das Modul `matplotlib` verwendet, das vorgängig installiert werden muss. Alle Programme, ausser denen, die dieses Modul verwenden, können auch in [TigerJython](https://tigerjython.ch/) ausgeführt werden.\n\nIn @sec-ADisnot wird das Modul `sympy` verwendet, das vorgängig installiert werden muss. Dieser Abschnitt kann auch übersprungen werden.\n\n@sec-SADforOneDimFunctions kann mit den gleichen Voraussetzungen wie @sec-AbleitungenUndAnwendungen bearbeitet werden. Für die @exr-SADmitSchleife sollte die `for`-Schleife bekannt sein. @exr-BillardSADmanualSOlution und @exr-MinDistlSolution beziehen sich auf die entsprechenden Aufgaben im @sec-NumerischeVerfahren. \nIn @sec-SadImplementationOperatorOverloading werden Klassen und das Überladen von Operatoren verwendet, um AD zu implementieren. Wenn die Schüler:innen damit noch nicht vertraut sind, kann das Konzept auch am Beispiel der AD eingeführt werden, wobei sicherlich zusätzliche Erklärungen durch die Lehrperson nötig sein werden. In @sec-sadPowerOperator benötigt man logarithmisches Differenzieren. Die Methode wir dort im Detail vorgeführt, falls sie jedoch nicht aus dem Mathematikunterricht bekannt ist, ist es sinnvoll, einige zusätzliche Übungsaufgaben dazu bereit zu stellen.\nDie @exr-billardMathsadSolutions und @exr-minDistSolutionWithSAD beziehen sich wiederum auf die entsprechenden Aufgaben in @sec-NumerischeVerfahren.\n\n@sec-HigherDimFunctions, @sec-AAD und @sec-ausblick setzen höherdimensionale Analysis, wie sie in einer Analysis 2 Vorlesung im ersten Studienjahr eingeführt werden, voraus. Insbesondere die Begriffe des Gradienten und der Jacobi Matrix sollten bekannt sein. Es wird in den Kapiteln auf Literatur verwiesen, in denen diese Begriffe kurz erklärt werden. Nichtsdestotrotz sollten auch diese Abschnitte für interessierte und leistungsstarke Schüler:innen zugänglich sein. Sie beinhalten weniger Übungsaufgaben und sind mehr als Ausblick für Interessierte gedacht. \nEs wird hier vom Modul `numpy` Gebrauch gemacht, das vorgängig installiert werden muss. Die benötigten Funktionen aus `numpy` werden ohne Kommentare verwendet. Im @sec-ausblick vergleichen wir unsere Klassen mit `autograd`, welches in `pytorch` enthalten ist. Dieses muss ebenfalls installiert werden (@PyTorch). \n\n\n### Durchführung der Lerneinheit\nIch habe Teile der Lerneinheit mit zwei Schulklassen durchgeführt. Die erste war eine 6. Klasse (Abschlussjahrgang des Langzeitgymnasiums) des Ergänzungsfachs Informatik. Ich unterrichtete die Klasse zwar nicht selber, aber im 2. Semester des Abschlussjahrs führen wir in den Ergänzungsfächern eine Sonderwoche durch, während der ich einen Tag gestaltet hatte. Die Klasse hatte Erfahrung in der Programmierung mit Java, aber nicht mit Python und auch objektorientierte Programmierung war vorher erst angeschnitten worden. \n\nAls Einstieg und Motivation für das Thema wählte ich das Newtonverfahren. Einige der Schüler:innen besuchten das Schwerpunktfach Physik/Anwendungen der Mathematik, in dem ich das Newtonverfahren bereits eingeführt hatte. Für die anderen beschränkte ich mich auf die Herleitung der Iterationsvorschrift und die Visualisierung mit GeoGebra im @sec-NumerischeVerfahren. Dass es auch Funktionen gibt, die sich nicht so leicht als eine einzeilige kompakte Formel hinschreiben lassen, wird schön durch das Billardproblem in @exm-Billard illustriert. \n\nDa noch nicht alle Schüler:innen mit Python programmiert hatten, folgte als nächstes eine kurze Einführung in die Syntax. Als Programmierumgebung habe ich [Codeboard.io](https://codeboard.io/) verwendet, welches im Browser verwendet werden kann und im Gegensatz zu [TigerJython](https://tigerjython.ch/) auch `numpy` und `matplotlib` unterstützt. Bei letzterer muss allerdings die Ausgabe als Bild abgespeichert werden und dann auf der Konsole ausgedruckt werden. Das folgende einfache Beispiel verdeutlicht das Vorgehen:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"false\"}\nimport matplotlib\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\n\nx = [0,1,2,3,4]\ny = [0,1,4,9,16]\n\nplt.plot(x,y)\nplt.savefig('plot.png')\nprint(\"<img width=\\\"350px\\\" src=\\\"/resources/plot.png\\\">\")\n```\n:::\n\n\nUm mit der Lerneinheit starten zu können, reicht es zu wissen, wie Bibliotheken wie z.B. `math` eingebunden werden und wie Funktionen definiert werden. Die Konzepte waren den Schüler:innen bekannt, nur die Syntax war neu, weshalb ich bei der Einführung gleich die Beispiele aus @sec-ProgFunc verwendete. Die Übungsaufgaben dieses Kapitels reichten auch schon aus, um sich mit der Syntax vertraut zu machen. Die Schüler:innen bearbeiteten danach selbständig die Aufgaben im @sec-ProgFunc und die schnelleren unter ihnen beschäftigten sich danach auch mit den Übungen im @sec-NumerischeVerfahren. \nDas @sec-ADisnot diskutierten wir danach kurz im Plenum, bevor sich die Schüler:innen in Paaren mit @sec-SadManualImplementation beschäftigten. Mit dem verlinkten GeoGebra App kann man die Korrektheit der Ausgabe für beliebige Funktionen überprüfen und ist nicht auf die Beispiele und Übungen beschränkt. Die Übungsaufgaben, die sich auf das Newtonverfahren und das Gradient Descent Verfahren beziehen, wurden wiederum nur von den schnelleren Schüler:innen bearbeitet. \n\nNach der Mittagspause widmeten wir uns dem @sec-SadImplementationOperatorOverloading zu. Der Begriff der Klasse war den Schüler:innen aus Java bekannt, sie hatten jedoch noch nicht viel Erfahrung mit dem Schreiben von eigenen Klassen und das für Python typische Operator Overloading war neu. Daher habe ich durch die ersten Abschnitte bis zur Implementation des Additionsoperators (@sec-implementAddSubtract) geführt und ausführlichere Erklärungen gegeben, als im Skript. Danach konnten sie wieder selbständig weiterarbeiten. Es gibt natürlich viele Aspekte der objektorientierten Programmierung, die in dieser Lerneinheit gar nicht angesprochen wurden, aber die Schüler:innen hatten ein erstes Erfolgserlebnis, bis zum Ende des Tages ihre erste funktionierende Klasse programmiert zu haben. \n\nDie zweite Durchführung geschah in einer 5. Klasse des Schwerpunktfaches Physik/Anwendungen der Mathematik, die ich selber unterrichte. Im Gegensatz zur 6. Klasse war diese die erste, welche im Vorjahr eine Einführung in Python im Rahmen des obligatorischen Fachs Informatik hatte. Wir beschäftigten uns vorher mit Anwendungen der Differentialrechnung und insbesondere mit dem Newtonverfahren. Es bot sich daher an, Algorithmisches Differenzieren als eine Ergänzung zu behandeln. Dies geschah im regulären Unterricht während insgesammt drei Doppellektionen à 90 Minuten. Da im Grundlagenfach zu diesem Zeitpunkt auch Optimierungsaufgaben besprochen wurden, habe ich die @exr-OptimierungsproblemProgrammieren als Einstieg ergänzt. \n\nIn der ersten Doppellektion beschäftigten wir uns mit @sec-AbleitungenUndAnwendungen, diesmal in chronologischer Abfolge. Das Newtonverfahren hatten wir bereits früher programmiert und dabei die Funktion jeweils \"von Hand\" abgeleitet, d.h. neben der Funktion `f` auch eine Funktion `df` definiert. Ich beauftragte die Schüler:innen, eine Methode zu entwickeln, die die Ableitung automatisch berechnet. Die Idee, den Wert der Ableitung durch einen Differenzenquotienten mit kleinem `h` zu approximieren, kam wider erwarten erst, als ich den Hinweis gab, dass wir die Funktion nur an einer bestimmten Stelle auszuwerten brauchen und die Definition der Ableitung in Erinnerung gerufen hatte. Der Fokus der Schüler:innen lag zunächst nur auf dem Anwenden von Ableitungsregeln.  \n\nIn der zweiten Lektion konnte ich hier anknüpfen und @sec-ADisnot besprechen. Danach bearbeiteten die Schüler:innen wieder selbständig das @sec-SadManualImplementation. Im Gegensatz zum Ergänzungsfach legte ich den Fokus etwas stärker auf das Newtonverfahren und die Lösung des Billardproblems, da sie mit dieser Fragestellung bereits vertraut waren. \n\nDie dritte Lektion benutzten wir dazu, die angefangenen Übungsaufgaben abzuschliessen und ich gab in Form eines Lehrervortrags einen Ausblick auf die @sec-HigherDimFunctions und @sec-AAD, welche einige Anwendungen der AD aufzeigen.\n\nMeine Hoffnung haben sich damit weitestgehend erfüllt, dass die vorliegende Arbeit sowohl im Informatik- wie auch im Mathematikunterricht gewinnbringend eingesetzt werden kann. Allerdings habe ich sie erst mit Schüler:innen durchgeführt, die sich für eines von diesen oder für beide Fächer entschieden haben. Der eigentliche Test, nämlich der Einsatz in einem Grundlagenfach mit allen Schüler:innen, ist noch ausstehend. \n\n\n### Potential für den Mathematikunterricht\nBevor ich mit der Einführung von Differentialrechnung beginne, mache ich mit der Klasse häufig Übungen, in denen die Schüler:innen mathematische Terme möglichst präzise beschreiben sollen. Der Term $\\frac{2+\\sqrt x}{x^2-2^x}$ kann beispielsweise so beschrieben werden: \n|  Der Term ist ein Quotient. Der Dividend ist eine Summe, deren erster Summand eine Konstante Zwei und deren zweiter Summand die Quadratwurzel von $x$ ist. Der Divisor ist eine Differenz. Der Minuend ist die zweite Potenz von $x$ und der Subtrahend ist die Exponentialfunktion zur Basis Zwei.\n\nDas Ziel dieser Übung ist nicht nur, sich die Fachbegriffe anzueignen, sondern auch, die Struktur eines mathematischen Ausdrucks zu erfassen. Das ist nicht nur für das Lösen von Gleichungen, sondern insbesondere auch für die korrekte Anwendung der Ableitungsregeln notwendig. Ich habe festgestellt, dass das regelmässige Durchführen solcher Übungen die Häufigkeit von Fehlern in Ableitungen verkleinert. Angeregt zu solchen Übungen wurde ich durch Josef Züger von der Bündner Kantonsschule. \n\nDie @exr-OptimierungsproblemNachKonvention, @exr-ProgToFun und @exr-FunToGraphProg, bei denen die Berechnung eines Ausdrucks in elementare Schritte zerlegt wird, erfüllen den gleichen Zweck. \n\nWie das Beispiel zu Beginn von @sec-SadManualImplementation zeigt, ist das manuelle Durchführen der SAD eine gute Übung zur Anwendung der Kettenregel und der anderen Ableitungsregeln. Da an vielen Schulen nun alle Schüler:innen aus dem Fach Informatik mit Python vertraut sind, können Aufgaben wie @exr-ErstesADBspErweitern, @exr-SADKostenfunktionManuell und @exr-SADProduktregel auch als Ergänzung im Mathematikunterricht eingesetzt werden, oder sogar als Motivation für die Einführung der Kettenregel dienen. \n\nWie im @sec-sadPowerOperator gezeigt wird, bietet die AD auch eine Motivation, logarithmisches Differenzieren zu behandeln. An unserer Schule haben wir das vor einigen Jahren aus dem Curriculum gestrichen - nicht nur aus Zeitgründen, sondern auch, weil Schüler:innen nach einiger Zeit müde werden, noch eine Ableitungsregel zu lernen, die später ohnehing fast nicht mehr gebraucht wurde. \n\nSchliesslich bietet die AD, wie schon an mehreren Stellen in dieser Arbeit dargelegt wurde, viele echte Anwendungen der Differentialrechnung, die mindestens so interessant sind wie eine Kurvendiskussion, welche meist als Anwendung verkauft wird.\n\n\n### Potential für den Informatikunterricht\nAn unserer Schule findet das obligatorische Fach in der 3. und 4. Klasse des Langzeitgymnasiums statt, während die Differentialrechnung im Mathematikunterricht erst in der 5. Klasse behandelt wird. Daher bietet sich die Lerneinheit momentan nur für ein Ergänzungsfach an. Hier bietet sich aber die Gelegenheit, am Beispiel der AD objektorientierte Programmierung einzuführen, und dabei auch noch viele Querverbindungen zum Grundlagenfach Mathematik oder zum Schwerpunktfach zu ziehen. \n\nMit der anstehenden Weiterentwicklung der gymnasialen Maturtät wird das obligatorische Fach Informatik wohl zum Grundlagenfach erhoben. Es ist daher auch möglich, dass die Stundendotation des Fachs erhöht und bis in die 5. Klasse weitergeführt wird. Dann könnte diese Lerneinheit auch in einem Grundlagenfach Informatik durchgeführt werden.\n\n\n### Verbesserungen für künftige Klassen\n@sec-AbleitungenUndAnwendungen und @sec-SadManualImplementation legen den Fokus auf die Mathematik und die Anwendungen mit dem Newtonverfahren und der Gradient Descent Methode. @sec-SadImplementationOperatorOverloading befasst sich mit den programmiertechnischen Aspekten. Dabei habe ich versucht, auf eine ausgewogene Anzahl an Übungsaufgaben in allen Teilen zu achten. Das mag jedoch dazu führen, dass es je nach Zielgruppe zu viele oder zu wenige Übungsaufgaben gibt. \nFür den mathematischen Teil würde ich mehr Aufgaben zum Zeichnen oder Interpretieren von Computational Graphs anfügen, die auch alle Funktionstypen abdecken, oder beim manuellen Ableiten von Funktionen auch Beispiele für die Quotientenregel ergänzen. Andererseits werden auch \"Tricks\" wie List Comprehensions in diesem Teil verwendet, etwa im @exm-Billard, welche Schüler:innen aus dem obligatorischen Fach Informatik nicht bekannt sein dürften. Die Übungen beim Implementieren der Klassen wiederum bieten wenig Abwechslung für Programmierer.\n\nVerschiedene, gekürzte Versionen des Skripts, die besser auf die eine oder andere Zielgruppe zugeschnitten sind, könnte die Lerneinheit als ganzes attraktiver machen. Ausserdem werde ich in einer Version, die ich später im Unterricht einsetze, alle für die Schüler:innen nicht relevanten Teile - wie diese Reflexion - wieder löschen. Für den Einsatz im Immersionsunterricht möchte ich ausserdem die Lerneinheit oder Teile davon zu eine späteren Zeitpunkt noch auf Englisch übersetzen.\n\n\n## Was ich persönlich gelernt habe\nAuch für mich war es das erste Mal, dass ich in der Programmiersprache Python ein grösseres Projekt implementiert habe. Dabei hatte ich auch die Gelegenheit, mich mit `matplotlib`, `numpy`, `sympy` oder `pytorch` ein wenig vertraut zu machen, obschon ich da bestenfalls\nan der Oberfläche gekratzt habe. Für das @sec-HigherDimFunctions und @sec-AAD konnte ich einige Konzepte aus der Analysis 2 Vorlesung wieder auffrischen.\n\nSehr gute Erfahrungen habe ich mit Quarto und dem Erstellen des Skripts in Form einer Website gemacht. Die Lernkurve war anfangs etwas steil, es lassen sich danach aber ansprechende Webseiten mit geringem Aufwand erstellen. Die Kombination von Markdown, Latex und ausführbarem Python Code werde ich auch in Zukunft für die Erstellung von Lerneinheiten einsetzen. In Zeiten von Bring Your Own Device erscheint mir eine Webseite mit interaktiven Elementen zeitgemässer als ein statisches Pdf. \n\nSchliesslich habe ich während dieser Arbeit auch zum ersten Mal intensiv GitHub verwendet, um Fortschritte zu sichern und die Webseite zu veröffentlichen. Das zugehörige GitHub Repository könnte allerdings aufgeräumter sein. Bei Commits sollte ich darauf achten, immer nur Änderungen zu einem Abschnitt oder zu einem Thema einzufügen, aber glücklicherweise musste ich das Projekt nie auf einen früheren Zeitpunkt zurücksetzen. Auf jeden Fall möchte ich die verwendeten Tools auch in künftigen Projekten nicht missen.\n\n",
    "supporting": [
      "reflexion_files"
    ],
    "filters": [],
    "includes": {}
  }
}