{
  "hash": "2c17c8687f4e818f5da6d60c67a2794c",
  "result": {
    "markdown": "---\ntbl-cap-location: bottom\n---\n\n# Standard Algorithmische Differentiation für eindimensionale Funktionen {#sec-SADforOneDimFunctions}\n\nIn @sec-ADisnot haben wir zwei Methoden für die Berechnung von Ableitungen kennen gelernt, die beide ihre Schwächen  haben. Während die numerische Ableitung mit geringem Aufwand berechnet werden kann, sind ihre Näherungswerte für viele Anwendungen zu ungenau. Symbolische Ableitungen andererseits liefern zwar exakte Werte von Ableitungen, sind aber mit grossem Rechenaufwand verbunden. Die hier vorgestellte Algorithmische Differentiation (AD) vereinigt die Vorteile der beiden Methoden. Sie liefert uns (bis auf Maschinengenauigkeit) exakte Werte von Ableitungen mit nur einem geringen zusätzlichen Rechenaufwand:\n\n> \"AD as a technical term refers to a specific family of techniques that compute derivatives trhough accumulation of values during code execution to generate numerical derivative evaluations rather than derivative expressions. This allows accurate evaluation of derivatives at machine precision with only a small constant factor of overhead and ideal asymptotic efficiency.\" (@Baydin18, S. 2)\n\nIn diesem Kapitel lernen wir die *Standard Algorithmische Differentiation* (SAD, auch Vorwärts-AD genannt) kennen, welche die einfachste Variante der erwähnten \"family of techniques\" ist. Wir beschränken uns zunächst wieder auf Funktionen $f : \\mathbb{R} \\rightarrow \\mathbb{R}$ und werden dies später auf Funktionen $f : \\mathbb{R}^n \\rightarrow \\mathbb{R}^m$ erweitern. Neben der Standard-AD gibt es noch die *Adjungierte Algorithmische Differentiation* (AAD, auch Rückwärts-AD genannt). Die Vorteile dieser Methode offenbaren sich jedoch erst für Funktionen in höherdimensionalen Räumen. Der interessierte Leser findet hierzu eine kurze Einführung in @sec-AAD.\n\nGemäss unserer Konvention in @sec-ProgFunc berechnen wir eine mathematische Funktion, indem wir sie in ihre Bestandteile zerlegen, und die Zwischenergebnisse Variablen `v` zuweisen. Wie im obigen Zitat erwähnt, besteht die Grundidee der AD darin, eine Reihe von Hilfsvariablen `vdot` einzuführen, welche jeweils die Werte der Ableitungen enthalten. In diesem Kapitel machen wir dies explizit, indem wir jede Programmzeile, die ein `v` berechnet, um die Berechnung des zugehörigen `vdot` erweitern. Dies scheint zunächst umständlich zu sein, aber im nächsten Abschnitt werden wir eine Klasse schreiben, die diese Schritte für uns automatisiert. Wie Marc Henrard in seinem Buch schreibt:\n\n> \"There are as many shades of AD as there are AD users. [This chapter] provides to the user the black and the white; it is up to him to get the correct shade of grey that fits his taste and his requirements.\" (@Henrard2017ADi, S. 18)\n\n## Manuelle Implementation der SAD {#sec-SadManualImplementation}\n\nBeginnen wir mit einem Beispiel:\n\nWir möchten den Funktionswert und die Ableitung der Funktion $y=f(x)=\\sin(x^2)$ an der Stelle $x_0=\\frac{\\pi}{2}$ bestimmen. Das folgende Programm berechnet den Funktionswert.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"show\"}\nimport math\n\ndef f(x):\n    v0 = x\n    v1 = v0**2\n    v2 = math.sin(v1)\n    y = v2\n    return y\n\nx0 = math.pi / 2\nprint(f(x0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.6242659526396992\n```\n:::\n:::\n\n\n$f$ ist eine zusammengesetzte Funktion, die wir mit den Funktionen\n\n\\begin{align*}\n    v_0(x)   &= x \\\\\n    v_1(v_0) &= v_0 ^2 \\\\\n    v_2(v_1) &= \\sin(v_1)\n\\end{align*}\n\nschreiben können als $y=f(x)=v_2(v_1(v_0(x)))$. Die Ableitung berechnet sich dann mit der Kettenregel zu\n$$\nf'(x) = \\frac{dv_2}{dv_1} \\cdot \\frac{dv_1}{dv_0} \\cdot \\frac{dv_0}{dx} = \\cos(v_1)\\cdot 2v_0 \\cdot 1 = \\cos(x^2) \\cdot 2x \\cdot 1\n$$\nWir können also die Ableitung von `f(x)` berechnen, indem wir jede Zeile des Programms gemäss den bekannten Regeln ableiten:\n```\nv0dot = 1\nv1dot = 2 * v0 * v0dot\nv2dot = math.cos(v1) * v1dot\n```\nMan beachte, dass durch die Konvention, dass immer `v0 = x` gesetzt wird, auch immer `v0dot = 1` ist. Nun können wir unsere Funktion so ergänzen, dass nicht nur der Funktionswert, sondern auch die Ableitung an der Stelle $x_0$ berechnet wird:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"show\"}\nimport math\n\ndef f(x):\n    v0dot = 1\n    v0 = x\n    v1dot = 2 * v0 * v0dot\n    v1 = v0**2\n    v2dot = math.cos(v1) * v1dot\n    v2 = math.sin(v1)\n    ydot = v2dot\n    y = v2\n    return [y, ydot]\n\nx0 = math.pi / 2\nprint(f(x0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.6242659526396992, -2.4542495411512917]\n```\n:::\n:::\n\n\nDie Korrektheit des Programms können wir mit [GeoGebra](https://www.geogebra.org/m/u4rkpzsr) überprüfen, welches Ableitungen symbolisch berechnet.\n\n:::{.content-visible unless-format=\"pdf\"}\n\n::::{.fig-AbleitungenTesten}\n\n<iframe scrolling=\"no\" title=\"Ableitungen berechnen\" src=\"https://www.geogebra.org/material/iframe/id/nghnrzye/width/700/height/500/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/true/rc/false/ld/false/sdz/true/ctl/false\" width=\"700px\" height=\"500px\" style=\"border:0px;\"> </iframe>\n\n::::\n\n:::\n\nBeachte, dass wir konsequent die Kettenregel verwendet haben. So wird aus `v1 = v0**2` etwa `v1dot = 2 * v0 * v0dot` oder aus `v2 = sin(v1)` wird `v2dot = cos(v1) * v1dot`. \n\n:::{#exr-ErstesADBspErweitern}\n\n## Programm ableiten\n<br>\n\nÄndere das vorherige Programm so ab, dass der Funktionswert und die Ableitung der Funktion $y = f(x) = \\ln(\\sin(x^2))$ an der Stelle $x_0 = \\frac{\\pi}{2}$ berechnet wird. Überprüfe deine Lösung mit GeoGebra.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\nEs müssen lediglich zwei weitere Zeilen eingefügt werden und zwar für die Berechnung von `v3` und `v3dot`. Vergiss nicht, die richtigen Werte zurückzugeben.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport math\n\ndef f(x):\n    v0dot = 1\n    v0 = x\n    v1dot = 2 * v0 * v0dot\n    v1 = v0**2\n    v2dot = math.cos(v1) * v1dot\n    v2 = math.sin(v1)\n    v3dot = 1 / v2 * v2dot\n    v3 = math.log(v2)\n    ydot = v3dot\n    y = v3\n    return [y, ydot]\n\nx0 = math.pi / 2\nprint(f(x0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-0.4711787952593891, -3.9314166194288416]\n```\n:::\n:::\n\n\n:::\n\n:::{.callout-important}\n\n## Konvention\n\nEin Programm, welches gemäss der Konvention in @sec-ProgFunc geschrieben ist, wird folgendermassen abgeleitet:\n\n1. Für jede Variable `v` wird eine neue Variable `vdot` für den Wert der Ableitung definiert, angefangen bei `v0dot = 1`. \n2. Jede Programmzeile wird gemäss den bekannten Regeln aus @tbl-DiffGrundfunktionen und @tbl-DiffRegeln abgeleitet. Dabei wird insbesondere in *jeder* Zeile die Kettenregel verwendet.\n3. Die abgeleitete Anweisung wird jeweils *vor* (!) die zu ableitende Anweisung eingeschoben.\n\n:::\n\n:::{#exr-SADProduktregel}\n\n## Produktregel\n<br>\n\nDas folgende Programm berechnet die Funktion $y = f(x) = (2+x)(x-3)$:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\ndef f(x):\n    v0 = x\n    v1 = 2 + v0\n    v2 = v0 - 3\n    y = v1 * v2\n    return y\n```\n:::\n\n\nLeite dieses Programm ab. Dein Programm soll die Gleichung der Tangente $t(x) = f(x_0) + f'(x_0)\\cdot (x-x_0)$ an der Stelle $x_0 = 2$ ausgeben.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef f(x):\n    v0dot = 1\n    v0 = x\n    v1dot = v0dot\n    v1 = 2 + v0\n    v2dot = v0dot\n    v2 = v0 - 3\n    ydot = v1dot * v2 + v1 * v2dot # Produktregel\n    y = v1 * v2\n    return [y, ydot]\n\nx0 = 2\n[y0, y0dot] = f(x0)\nprint(\"t(x) =\", y0, \"+\", y0dot, \"* ( x -\", x0, \")\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nt(x) = -4 + 3 * ( x - 2 )\n```\n:::\n:::\n\n\n:::\n\n:::{#exr-SAD1}\n\n## Programm ableiten\n<br>\n\nLeite die Funktion aus @exr-ProgToFun ab. Gib den Funktionswert und den Wert der Ableitung an der Stelle $x_0=-2$ aus.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport math\n\ndef f(x):\n    v0dot = 1\n    v0 = x\n    v1dot = 2 * v0 * v0dot\n    v1 = v0 ** 2\n    v2dot = v1dot\n    v2 = v1 + 2\n    v3dot = -1/2 * v1dot\n    v3 = -v1 / 2\n    v4dot = -math.sin(v2) * v2dot\n    v4 = math.cos(v2)\n    v5dot = math.exp(v3) * v3dot\n    v5 = math.exp(v3)\n    v6dot = v4dot * v5 + v4 * v5dot\n    v6 = v4 * v5\n    ydot = v6dot - 1 / v0**2 * v0dot\n    y = v6 + 1 / v0\n    return [y, ydot]\n\nx0 = -2\nprint(f(x0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-0.3700550823007931, -0.14136926695938976]\n```\n:::\n:::\n\n\n:::\n\n:::{#exr-SAD2}\n\n## Programm ableiten\n<br>\n\nLeite die Funktion aus @exr-FunToGraphProg ab.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport math\n\ndef f(x):\n    v0dot = 1\n    v0 = x\n    v1dot = 2 * v0 * v0dot\n    v1 = v0 ** 2\n    v2dot = v1dot\n    v2 = v1 + 1\n    v3dot = v2dot + v0dot\n    v3 = v2 + v0\n    v4dot = 1 / v2 * v2dot\n    v4 = math.log(v2)\n    v5dot = 1 / (2 * math.sqrt(v3)) * v3dot\n    v5 = math.sqrt(v3)\n    ydot = (v4dot * v5 - v4 * v5dot) / v5**2\n    y = v4 / v5\n    return [y, ydot]\n```\n:::\n\n\n:::\n\nBei all diesen Beispielen könnten wir auch die Reihenfolge der Anweisungen für `vdot` und `v` vertauschen, d.h. zuerst die Variable `v` berechnen und erst danach das zugehörige `vdot`. Die folgende Übung zeigt aber, warum der 3. Punkt unserer Konvention wichtig ist.\n\n:::{#exr-SADmitSchleife}\n\n## Ein Programm mit einer Schleife\n<br>\n\nBetrachte die Funktion aus @exr-LoopProgToFun, welche aus $\\ell(x) = x^2 + 1$ die Funktion $y = f(x) = \\ell(\\ell(\\ell(x)))$ berechnet. Aus @exm-symbDiff wissen wir, dass $f'(1) = 80$ ist. Vergleiche nun die beiden Varianten für die Ableitung des Programms:\n\n::::{.panel-tabset}\n\n## `vdot` vor `v`\n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"false\"}\ndef f(x):\n    v0dot = 1\n    v0 = x\n    for i in range(3):\n        v0dot = 2 * v0 * v0dot\n        v0 = v0 ** 2 + 1\n    ydot = v0dot\n    y = v0\n    return [y, ydot]\n\nprint(f(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[26, 80]\n```\n:::\n:::\n\n\n## `v` vor `vdot`\n\n::: {.cell execution_count=9}\n``` {.python .cell-code code-fold=\"false\"}\ndef f(x):\n    v0 = x\n    v0dot = 1\n    for i in range(3):\n        v0 = v0 ** 2 + 1\n        v0dot = 2 * v0 * v0dot\n    y = v0\n    ydot = v0dot\n    return [y, ydot]\n\nprint(f(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[26, 2080]\n```\n:::\n:::\n\n\n::::\n\nWarum wird bei der 2. Variante der Wert der Ableitung falsch berechnet?\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\nDas Problem tritt in der Schleife auf. In der 2. Variante überschreiben wir den Wert von `v0` bereits mit dem neuen Wert der Iteration. Bei der Berechnung von `v0dot` hätten wir aber noch den alten Wert gebraucht. Die Reihenfolge ist also nur in der 1. Version korrekt. Würden wir die Schleife eliminieren und dafür wie in der Lösung zu @exr-LoopProgToFun für jeden Schleifendurchgang fortlaufend numerierte Variablen für die `v` und `vdot` verwenden, dann wäre die Reihenfolge wieder egal. \n\n:::\n\nIn der nächsten Übungsaufgabe verwenden wir die Technik der AD, um das Billardproblem aus @sec-Newtonverfahren1D mit dem Newtonverfahren zu lösen. Da uns die Funktion `f(x)` nun nicht mehr nur der Funktionswert, sondern auch die Ableitung berechnet, können wir das Newtonverfahren ohne die Probleme aus @exr-NewtonFirstTry implementieren.\n\n:::{#exr-BillardSADmanualSOlution}\n\n## Das Billard-Problem\n<br>\n\nLeite das Programm aus @exm-Billard ab.\nSchreibe danach eine Funktion `newton(f, x0)`, welche ausnutzt, dass der Funktionsaufruf `f(x0)` auch den exakten Wert der Ableitung zurückgibt.\nStelle alle gefundenen Lösungen grafisch dar.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nimport math\nimport matplotlib.pyplot as plt\n\ndef f(x):\n    # Parameter werden im global space gefunden\n    # Berechnung des Skalarprodukts und dessen Ableitung\n    v0dot = 1\n    v0 = x\n    v1dot = -math.sin(v0) * v0dot  # Ableitung von ...\n    v1 = math.cos(v0)  # x-Koordinate von X\n    v2dot = math.cos(v0) * v0dot   # Ableitung von ...\n    v2 = math.sin(v0)  # y-Koordinate von X\n    v3dot = - v1dot    # Ableitung von ...\n    v3 = px - v1       # x-Komponente des Vektors XP\n    v4dot = - v2dot    # Ableitung von ...\n    v4 = py - v2       # y-Komponente des Vektors XP\n    v5dot = 1 / (2*math.sqrt(v3**2 + v4**2)) \\\n        * (2*v3*v3dot + 2*v4*v4dot)  # Ableitung von ...\n    v5 = math.sqrt(v3**2 + v4**2)  # Länge des Vektors XP\n    v6dot = (v3dot * v5 - v3 * v5dot) / v5**2  # Ableitung von ...\n    v6 = v3 / v5       # x-Komponente des Einheitsvektors eP\n    v7dot = (v4dot * v5 - v4 * v5dot) / v5**2  # Ableitung von ...\n    v7 = v4 / v5       # y-Komponente des Einheitsvektors eP\n    v8dot = -v1dot     # Ableitung von ...\n    v8 = a - v1        # x-Komponente des Vektors XQ\n    v9dot = -v2dot     # Ableitung von ...\n    v9 = -v2           # y-Komponente des Vektors XQ\n    v10dot = 1 / (2*math.sqrt(v8**2 + v9**2)) \\\n        * (2*v8*v8dot + 2*v9*v9dot)  # Ableitung von ...\n    v10 = math.sqrt(v8**2 + v9**2)  # Länge des Vektors XQ\n    v11dot = (v8dot * v10 - v8 * v10dot) / v10**2  # Ableitung von ...\n    v11 = v8 / v10     # x-Komponente des Vektors eQ    \n    v12dot = (v9dot * v10 - v9 * v10dot) / v10**2  # Ableitung von ... \n    v12 = v9 / v10     # y-Komponente des Vektors eQ   \n    ydot = (v6dot + v11dot) * v2 + (v6 + v11) * v2dot \\\n        - ( (v7dot + v12dot) * v1 + (v7 + v12) * v1dot )  # Ableitung von ...\n    y = (v6 + v11) * v2 - (v7 + v12) * v1\n    return [y, ydot]   \n\ndef newton(f, x0):\n    tol = 1e-8\n    # Erster Schritt berechnen\n    [y0, y0dot] = f(x0)\n    x1 = x0 - y0 / y0dot\n    while math.fabs(x1 - x0) > tol:\n        x0 = x1\n        [y0, y0dot] = f(x0)\n        x1 = x0 - y0 / y0dot\n    return x1 \n\n\nif __name__ == \"__main__\":\n\n    # Parameter definieren\n    a = -0.8           # Position von Q = (a|0)\n    px, py = 0.5, 0.5  # Position von P = (px|py)\n\n    # Lösung des Billardproblems berechnen\n    sol = set({}) # leere Menge, in der die gefundenen Lösungen gespeichert werden\n    X = [2*math.pi * k / 10 for k in range(10)]  # Liste der Startwerte für Newton\n    for x0 in X:\n        x = newton(f, x0)\n        sol.add(x)\n\n    # Lösungen grafisch darstellen\n    fig = plt.figure()\n    ax = plt.gca()\n    ax.set_xlim((-1.2, 1.2))\n    ax.set_ylim((-1.2, 1.2))\n    ax.set_aspect('equal')\n    circle = plt.Circle((0,0), 1, color='b', fill=False)\n    qBall = plt.Circle((a,0), 0.02, color='k')\n    pBall = plt.Circle([px, py], 0.02, color='k')\n    ax.add_patch(circle)\n    ax.add_patch(qBall)\n    ax.add_patch(pBall)\n    for x in sol:\n        xcoords = [a, math.cos(x), px]\n        ycoords = [0, math.sin(x), py]\n        plt.plot(xcoords, ycoords, linewidth=1, linestyle='--')\n    plt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Lösung des Billardproblems.](ADOneDimManually_files/figure-html/fig-billardproblemsolution-output-1.png){#fig-billardproblemsolution width=423 height=404}\n:::\n:::\n\n\n:::\n\n:::{#exr-MinDistlSolution}\n\n## Minimaler Abstand\n<br>\n\nLeite das Programm aus @exm-GDApplication ab.\nSchreibe danach eine Funktion `gradient_descent(f, x0, lam)`, welche ausnutzt, dass der Funktionsaufruf `f(x0)` auch den exakten Wert der Ableitung zurückgibt.\nStelle die gefundene Lösung grafisch dar.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport math\nimport matplotlib.pyplot as plt\n\ndef d(t):\n    v0dot = 1                    \n    v0 = t\n    v1dot = -2 * math.sin(v0) * v0dot   # Ableitung von...\n    v1 = 2 * math.cos(v0) - 1    # x-Koordinate von P\n    v2dot = 1.5 * math.cos(v0) * v0dot  # Ableitung von...\n    v2 = 1.5 * math.sin(v0)      # y-Koordinate von P\n    v3dot = 0                    # Ableitung von...\n    v3 = 0                       # z-Koordinate von P\n    v4dot = -6 * math.cos(2*v0) * v0dot # Ableitung von...\n    v4 = -3 * math.sin(2*v0)     # x-Koordinate von Q\n    v5dot = -4 * math.sin(2*v0) * v0dot # Ableitung von...\n    v5 = 2 * math.cos(2*v0) + 1  # y-Koordinate von Q\n    v6dot = 4 * math.cos(2*v0) * v0dot  # Ableitung von...\n    v6 = 2 * math.sin(2*v0) + 1  # z-Koordinate von Q\n    ydot = (2*(v4-v1)*(v4dot-v1dot) + 2*(v5-v2)*(v5dot-v2dot) + 2*(v6-v3)*(v6dot-v3dot)) \\\n         / (2 * math.sqrt((v4-v1)**2 + (v5-v2)**2 + (v6-v3)**2))\n    y = math.sqrt((v4-v1)**2 + (v5-v2)**2 + (v6-v3)**2)\n    return [y, ydot]\n\ndef gradient_descent(f, x0, lam):\n    tol = 1e-9\n    # Erster Schritt berechnen\n    [y0, y0dot] = f(x0)\n    x1 = x0 - lam * y0dot\n    while math.fabs(x1-x0) > tol:\n        x0 = x1\n        [y0, y0dot] = f(x0)\n        x1 = x0 - lam * y0dot\n    return x1\n\nif __name__ == \"__main__\":\n    t0 = 3\n    tmin = gradient_descent(d, t0, 0.01)\n    [dmin, dmindot] = d(tmin)\n    print(\"Minimum bei (\", tmin, dmin, \")\")\n\n    fig = plt.figure()\n    ax = plt.gca()\n    ax.set_xlim((0,2*math.pi))\n    ax.set_ylim((0,6))\n    T = [2*math.pi * k / 1000 for k in range(1001)]\n    Y = [d(t)[0] for t in T]  # nur Funktionswert plotten\n    plt.plot(T,Y)\n    plt.xticks([0, math.pi/2, math.pi, 3*math.pi/2, 2*math.pi],\n               ['0', 'π/2', 'π', '3π/2', '2π'])\n    plt.plot(tmin,dmin,color='r', marker='o')\n    plt.show()      \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMinimum bei ( 4.712388977478413 1.5 )\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Kürzester Abstand mit Gradient Descent.](ADOneDimManually_files/figure-html/fig-mindistproblemsolution-output-2.png){#fig-mindistproblemsolution width=566 height=409}\n:::\n:::\n\n\nBeachte, dass beim Zeichnen des Funktionsgraphen neu `Y = [d(t)[0] for t in T]` steht. Der Grund dafür ist, dass `d(t)` nun eine Liste mit zwei Elementen ist (Funktionswert und Ableitung) und wir nur den Funktionswert zeichnen wollen. Schreibt man stattdessen `Y = [d(t) for t in T]`, dann wird zusätzlich auch der Graph der Ableitung gezeichnet.\n\n:::\n\n\n\n\n\n## Implementation der SAD mit Operator Overloading {#sec-SadImplementationOperatorOverloading}\n\nNach dem letzten Abschnitt könnte man einwenden, dass wir die Ableitungen der Funktionen ja doch von Hand berechnet haben, denn wir haben jede Programmzeile, in der eine Variable `v` berechnet wird, um eine weitere Zeile ergänzt, in der wir `vdot` nach den bekannten Ableitungsregeln berechnet haben. Dieser Einwand ist auch berechtigt - oder wie es Henrard ausdrückt:\n\n> \"The bad news is that it [calculating the derivatives] has to be done; it will not appear magically. It is not only a figure of speech that 'something has to be done' but that to have it working everything has to be done\". [@Henrard2017ADi, S. 17]\n\nDie gute Nachricht ist, dass wir diesen Prozess weiter automatisieren können. Wir kennen die Ableitungsregeln für die elementaren Operationen (`+,-,*,/`), sowie für die Grundfunktionen. In diesem Abschnitt werden wir eine Klasse `FloatSad` schreiben, deren Instanzen Funktionswerte und Werte der Ableitung speichern. Da solche Werte in der Regel vom Typ `float` sind und wir die Standard-AD implementieren, nennen wir die Klasse `FloatSad`. Die Arbeit besteht dann darin, die Ableitungsregeln richtig in den Operatoren dieser Klasse zu kodieren. Da Python *Operator Overloading* kennt, werden wir dann nach getaner Arbeit die Ableitungen wirklich ohne zusätzlichen Programmieraufwand erhalten. \n\nDer Grundstein für unsere Klasse wurde bereits im 19. Jahrhundert gelegt, wie die folgende Infobox zeigt:\n\n:::{.callout-note collapse=\"true\"}\n\n## Hintergrund: Duale Zahlen\n\nDuale Zahlen wurden 1873 durch William Clifford eingeführt und sind ähnlich definiert, wie komplexe Zahlen. Zur Erinnerung: Eine komplexe Zahl ist eine Zahl der Form $a + bi$, wobei $a,b \\in \\mathbb{R}$ sind und $i$ die Eigenschaft $i^2 = -1$ hat. Eine duale Zahl ist eine Zahl der Form $a + a'\\epsilon$, wobei wieder $a,a' \\in \\mathbb{R}$ gilt, aber $\\epsilon$ die Eigenschaft $\\epsilon^2 = 0$ hat. Nun kann man nach dem Permanenzprinzip die folgenden Operationen für duale Zahlen definieren:\n\n\\begin{alignat*}{3}\n    &\\textrm{Addition:} && (a+a'\\epsilon) + (b+b'\\epsilon) &&= (a+b) + (a'+b')\\epsilon \\\\ \\\\\n    &\\textrm{Subtraktion:} && (a+a'\\epsilon) - (b+b'\\epsilon) &&= (a-b) + (a'-b')\\epsilon \\\\ \\\\\n    &\\textrm{Multiplikation:}\\quad && (a+a'\\epsilon) \\cdot (b+b'\\epsilon) &&= ab + a'b\\epsilon + ab'\\epsilon + a'b'\\epsilon^2 \\\\\n    & && &&= ab + (a'b + ab')\\epsilon \\\\ \\\\\n    &\\textrm{Division:} && (\\textrm{für }b\\ne 0) \\quad \\frac{a+a'\\epsilon}{b+b'\\epsilon} &&= \\frac{(a+a'\\epsilon)(b-b'\\epsilon)}{(b+b'\\epsilon)(b-b'\\epsilon)} \\\\\n    & && &&= \\frac{ab+a'b\\epsilon-ab'\\epsilon-a'b'\\epsilon^2}{b^2 - (b')^2\\epsilon^2} \\\\ \n    & && &&= \\frac{ab + (a'b-ab')\\epsilon}{b^2} \\\\ \n    & && &&= \\frac{a}{b} + \\frac{a'b - ab'}{b^2} \\epsilon\n\\end{alignat*}\n\nWir sehen, dass der reelle Teil den Wert der Operation und der duale Teil den Wert der zugehörigen Ableitung enthält. Dies gilt auch für Potenzen, wie man unter Anwendung des binomischen Satzes sieht:\n\n\\begin{align*}\n    (a+a'\\epsilon)^n &= \\sum_{k=0}^n \\binom n k a^{n-k} (a'\\epsilon)^k  \\\\\n    &= a^n + n \\cdot a^{n-1} \\cdot a'\\epsilon + (\\textrm{Terme mit }\\epsilon^2) \\\\ \n    &= a^n + n \\cdot a^{n-1} \\cdot a' \\epsilon\n\\end{align*}\n\nIm dualen Teil erkennen wir die Kettenregel $(a^n)' = n\\cdot a^{n-1}\\cdot a'$. Damit können wir duale Zahlen auch in Polynome $p(x) = p_0 + p_1 x + p_2 x^2 + \\ldots + p_n x^n$ einsetzen. Wir erhalten dann\n\n\\begin{align*}\n    p(a+a'\\epsilon) &= p_0 + p_1 (a+a'\\epsilon) + p_2 (a+a'\\epsilon)^2 + \\ldots + p_n (a+a'\\epsilon)^n \\\\ \n    &= p_0 + p_1 a + p_1 a'\\epsilon + p_2 a^2 + p_2 \\cdot 2a a' \\epsilon + ... + p_n a^n + p_n \\cdot n a^{n-1} a' \\epsilon \\\\ \n    &= p_0 + p_1 a + p_2 a^2 + \\ldots p_n a^n + (p_1 + p_2 \\cdot 2a + \\ldots + p_n \\cdot n a^{n-1}) \\cdot a' \\epsilon \\\\\n    &= p(a) + p'(a) \\cdot a'\\epsilon\n\\end{align*}\n\nDieses Resultat lässt sich auf allgemeine Funktionen $f$ verallgemeinern (für den Beweis entwickelt man $f$ in eine Taylorreihe und macht die gleichen Überlegungen wie für ein Polynom):\n$$\nf(a+a'\\epsilon) = f(a) + f'(a)\\cdot a'\\epsilon\n$$\n\n([Wikipedia: Dual number](https://en.wikipedia.org/wiki/Dual_number) und @Slater2022)\n\n:::\n\n### Die Klasse `FloatSad`  {#sec-FoatSadClassDescription}\nBeginnen wir nun mit der Implementation unserer Klasse `FloatSad`. Analog zu den dualen Zahlen enthält jedes `FloatSad`-Objekt zwei Attribute. Das Attribut `value` speichert den Funktionswert und das Attribut `derivative` speichert den Wert der Ableitung. Im Konstruktor der Klasse setzen wir für `derivative` den Standardwert `1`. Damit können wir eine gewöhnliche `Float`-Zahl korrekt in ein `FloatSad` umwandeln. Dies wird im `main` Programm demonstriert.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code code-fold=\"show\"}\nimport math\n\nclass FloatSad:\n\n    def __init__(self, value, derivative = 1.0):\n        self.value = float(value)\n        self.derivative = derivative\n\n\nif __name__ == '__main__':\n\n    def f(x):\n        v0 = FloatSad(x)\n        y = v0\n        return y\n\n    x0 = 2\n    resultat = f(x0)\n    print(\"Funktionswert:\", resultat.value)\n    print(\"Ableitung:\", resultat.derivative)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFunktionswert: 2.0\nAbleitung: 1.0\n```\n:::\n:::\n\n\nIn der Funktion `f` haben wir nun unsere Konvention, dass `v0 = x` sein soll, dazu verwendet, den Zahlenwert `x` in ein `FloatSad`-Objekt umzuwandeln. Die Konvention `v0dot = 1` ist im Konstruktor kodiert. Von nun an machen wir also die folgende Konvention:\n\n:::{.callout-important}\n\n## Konvention\n\nEine Funktion berechnet aus einem Argument `x` vom Typ `float` oder `int` einen Rückgabewert `y` vom Typ `FloatSad` über eine Reihe von Hilfsvariablen `v`, die alle vom Typ `FloatSad` sind. Insbesondere setzen wir am Anfang immer `v0 = FloatSad(x)`.\n\n:::\n\nDas obige Programm berechnet also den Funktionswert und den Wert der Ableitung von $f(x) = x$ an der Stelle $x_0 = 2$.\n\nUm die Ausgabe etwas einfacher zu gestalten implementieren wir als nächstes die `print` Methode für unsere Klasse. Wir geben ein `FloatSad`-Objekt einfach in der Form `< value ; derivative >` aus.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code code-fold=\"false\"}\ndef __repr__(self):\n        return \"< \" + str(self.value) + \" ; \" + str(self.derivative) + \" >\"\n```\n:::\n\n\nDa wir nun die Funktion $f(x) = x$ programmieren können, wollen wir als nächstes auch die Funktion $f(x) = -x$ programmieren können. Wir müssen unsere `FloatSad`-Objekte also mit Vorzeichen versehen.\n\n### Vorzeichen\n\nNatürlich wollen wir nicht nur das negative Vorzeichen, sondern auch das positive Vorzeichen implementieren, damit wir in unseren Programmen z.B. `v1 = +v0` oder `v2 = -v0` schreiben können.\nBeim positiven Vorzeichen müssen wir nichts machen, wir geben also ein `FloatSad`-Objekt mit den gleichen Attributen zurück. Beim negativen Vorzeichen ändern beide Attribute ihr Vorzeichen.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code code-fold=\"false\"}\ndef __pos__(self):\n        return FloatSad(self.value, self.derivative)\n    \ndef __neg__(self):\n    newValue = -self.value\n    newDerivative = -self.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\nNun gehen wir daran, die Grundoperationen für `FloatSad`-Objekte zu implementieren.\n\n### Die Operatoren `+` und `-`\n\nWir möchten in unseren Programmen Anweisungen wie `v2 = v0 + v1` verwenden können. Gemäss der Summenregel können wir dazu einfach die Funktionswerte und auch die Werte der Ableitungen addieren. \n\n::: {.cell execution_count=15}\n``` {.python .cell-code code-fold=\"false\"}\ndef __add__(self, other):\n        newValue = self.value + other.value\n        newDerivative = self.derivative + other.derivative\n        return FloatSad(newValue, newDerivative)\n```\n:::\n\n\nNun können wir zwei `FloatSad`-Objekte miteinander addieren. Manchmal möchten wir aber auch ein `float`- oder `int`-Wert zu einem `FloatSad`-Objekt addieren, z.B. `v1 = v0 + 2`. Dazu machen wir eine Typabfrage und passen den Wert der Ableitung entsprechend der Konstantenregel an:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code code-fold=\"false\"}\ndef __add__(self, other):\n    if type(other) in (float, int):\n        newValue = self.value + other\n        newDerivative = self.derivative + 0.0\n    else:\n        newValue = self.value + other.value\n        newDerivative = self.derivative + other.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\nJetzt funktioniert zwar die Anweisung `v1 = v0 + 2`, aber die Anweisung `v1 = 2 + v0` erzeugt immer noch eine Fehlermeldung. Um dieses Problem zu beheben, müssen wir als nächstes den *reverse-add*-Operator implementieren.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code code-fold=\"false\"}\ndef __radd__(self, other):\n    if type(other) in (float, int):\n        newValue = other + self.value\n        newDerivative = 0.0 + self.derivative\n    else:\n        newValue = other.value + self.value\n        newDerivative = other.derivative + self.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\nHier ist die bisher implementierte Klasse zusammen mit einem kleinen Testprogramm.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code code-fold=\"show\"}\nimport math\n\nclass FloatSad:\n\n    def __init__(self, value, derivative = 1.0):\n        self.value = float(value)\n        self.derivative = derivative\n\n    def __repr__(self):\n        return \"< \" + str(self.value) + \" ; \" + str(self.derivative) + \" >\"\n\n\n    # unäre Operatoren\n\n    def __pos__(self):\n        return FloatSad(self.value, self.derivative)\n    \n    def __neg__(self):\n        newValue = -self.value\n        newDerivative = -self.derivative\n        return FloatSad(newValue, newDerivative)\n    \n\n    # binäre Operatoren\n\n    def __add__(self, other):\n        if type(other) in (float, int):\n            newValue = self.value + other\n            newDerivative = self.derivative + 0.0\n        else:\n            newValue = self.value + other.value\n            newDerivative = self.derivative + other.derivative\n        return FloatSad(newValue, newDerivative)\n\n    def __radd__(self, other):\n        if type(other) in (float, int):\n            newValue = other + self.value\n            newDerivative = 0.0 + self.derivative\n        else:\n            newValue = other.value + self.value\n            newDerivative = other.derivative + self.derivative\n        return FloatSad(newValue, newDerivative)\n    \n\n\nif __name__ == '__main__':\n\n    def f(x):\n        v0 = FloatSad(x)\n        v1 = -v0 \n        v2 = 3 + v1\n        v3 = v2 + v1\n        y  = +v3\n        return y\n\n    resultat = f(2)\n    print(resultat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n< -1.0 ; -2.0 >\n```\n:::\n:::\n\n\n:::{#exr-verifyFirstSADderivative}\n\n## Korrektheit überprüfen\n<br>\n\nWelche Funktion berechnet `f` im `main` Programm? Stimmt die Ausgabe?\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\nEs handelt sich um die Funktion $f(x) = 3 - 2x$. \nDie Ausgabe $f(2) = -1, f'(2) = -2$ ist also korrekt.\n\n:::\n\nFür die nächste Übung musst du das obige Programm kopieren und in einer Datei mit dem Namen `floatsad.py` abspeichern. Speichere die Datei im gleichen Ordner wie die anderen Dateien.\n\n:::{#exr-ImplementSub}\n\n## Den Operator `-` implementieren\n<br>\n\nImplementiere auf die gleiche Weise den `-`-Operator. Die Methoden lauten `__sub__(self, other)` bzw. `__rsub__(self, other)`.\nSchreibe auch eine Testfunktion `f`, welche die neuen Operatoren verwendet.\n\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndef __sub__(self, other):\n    if type(other) in (float, int):\n        newValue = self.value - other\n        newDerivative = self.derivative - 0.0\n    else:\n        newValue = self.value - other.value\n        newDerivative = self.derivative - other.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef __rsub__(self, other):\n    if type(other) in (float, int):\n        newValue = other - self.value\n        newDerivative = 0.0 - self.derivative\n    else:\n        newValue = other.value - self.value\n        newDerivative = other.derivative - self.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::\n\n### Die Operatoren `*` und `/`\n\nAls nächstes wollen wir die Multiplikation implementieren, um Anweisungen der Form `v2 = v0 * v1` ausführen zu können. Dazu müssen wir die Produktregel verwenden. Wie bei der Addition und der Subtraktion soll unser `*`-Operator aber auch Anweisungen der Form `v1 = v0 * 2` oder `v1 = -3 * v0` richtig auswerten, bei denen die Faktorregel angewendet wird. Dazu ist wieder eine Typabfrage nötig.\n\n:::{#exr-ImplementMul}\n\n## Den Operator `*` implementieren\n<br>\n\nErgänze die Datei `floatsad.py` mit den Methoden `__mul__(self, other)` und `__rmul__(self, other)`. \nÜberlege dir verschiedene Testfälle und überzeuge dich von der Korrektheit deines Programms. \n\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndef __mul__(self, other):\n    if type(other) in (float, int):\n        newValue = self.value * other\n        newDerivative = self.derivative * other\n    else:\n        newValue = self.value * other.value\n        newDerivative = self.derivative * other.value + self.value * other.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef __rmul__(self, other):\n    if type(other) in (float, int):\n        newValue = other * self.value\n        newDerivative = other * self.derivative\n    else:\n        newValue = other.value * self.value\n        newDerivative =  other.derivative * self.value + other.value * self.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::\n\nEs fehlt noch der Divisionsoperator, damit wir Anweisungen wie `v2 = v1 / v0` verwenden können. Da wir es bei differenzierbaren Funktionen immer mit `float`- bzw. `FloatSad`-Objekten zu tun haben, implementieren wir nur den `/`-Operator, also die Funktion `__truediv__(self, other)` und nicht den `//`-Operator. Wir wollen aber wieder die Fallunterscheidung nach den Typen machen, so dass auch Anweisungen wie `v1 = v0 / 4` verwendet werden können. Dabei benötigen wir nur die Faktorregel und nicht die Quotientenregel. Um schliesslich auch noch `v1 = -4 / v0` zu ermöglichen, muss noch `__rtruediv__(self, other)` implementiert werden. Bei letzterem darf nicht vergessen werden, dass auch die Kettenregel benutzt werden muss, denn $\\frac{dv_1}{dx} = \\frac{dv_1}{dv_0}\\cdot \\frac{dv_0}{dx} = \\frac{4}{v_0^2}\\cdot v_0'$. Quadrate kann man mit `math.pow(value, 2)` berechnen. Bei der Implementierung müssen wir uns übrigens nicht um Fehlerbehandlungen, wie das Abfangen einer Division durch Null, kümmern, weil diese bereits im `/`-Operator, den wir verwenden, implementiert sind.\n\n:::{#exr-ImplementTrueDiv}\n\n## Den Operator `/` implementieren\n<br>\n\nErgänze die Datei `floatsad.py` mit den Methoden `__truediv__(self, other)` und `__rtruediv__(self, other)`. Überlege dir auch wieder verschiedene Testfälle und überzeuge dich von der Korrektheit deines Programms.\n\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndef __truediv__(self, other):\n    if type(other) in (float, int):\n        newValue = self.value / other\n        newDerivative = self.derivative / other\n    else:\n        newValue = self.value / other.value\n        newDerivative = (self.derivative * other.value - self.value * other.derivative) / math.pow(other.value, 2)\n    return FloatSad(newValue, newDerivative)\n\ndef __rtruediv__(self, other):\n    if type(other) in (float, int):\n        newValue = other / self.value\n        newDerivative = - other / math.pow(self.value, 2) * self.derivative\n    else:\n        newValue = other.value / self.value\n        newDerivative = (other.derivative * self.value - other.value * self.derivative) / math.pow(self.value, 2) * self.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::\n\n### Der Operator `**`\n\nInteressant ist nun die Implementation des Potenzoperators. Hier sind mehrere Fallunterscheidungen nötig.\n\nBetrachten wir zuerst den Fall, `type(other) in (float, int)`, d.h. wir haben einen Ausdruck der Form `v1 = v0 ** 3`. In diesem Fall wenden wir die Potenzregel zusammen mit der Kettenregel an.\n\nIm zweiten Fall haben wir einen Ausdruck wie `v3 = v1 ** v2`. Wir müssen uns also zuerst überlegen, wie wir einen Ausdruck der Form $v_3 (x) = v_1(x) ^{v_2 (x)}$ überhaupt ableiten. Offenbar muss dazu $v_1(x) > 0$ gelten. Um die Ableitung zu finden wenden wir den Trick an, dass wir die Funktion zuerst logarithmieren,\n$$\n\\ln(v_3(x)) = \\ln(v_1(x) ^{v_2 (x)}) = v_2(x) \\cdot \\ln(v_1(x))\n$$\nund danach beide Seiten ableiten, wobei wir auf der rechten Seite die Produktregel anwenden:\n$$\n\\frac{d}{dx}(\\ln(v_3(x))) = v_2'(x) \\cdot \\ln(v_1(x)) + v_2(x) \\cdot \\frac{1}{v_1(x)} \\cdot v_1'(x)\n$$\nDie linke Seite ergibt andererseits $\\frac{d}{dx}(\\ln(v_3(x))) = \\frac{1}{v_3(x)}\\cdot v_3'(x)$, so dass wir nun nach $v_3'(x)$ auflösen können:\n\n\\begin{align*}\n    v_3'(x) &= v_3(x) \\cdot \\left( v_2'(x) \\cdot \\ln(v_1(x)) + \\frac{v_2(x)}{v_1(x)} \\cdot v_1'(x) \\right) \\\\ \n    &= v_1(x) ^{v_2 (x)} \\cdot \\left( \\ln(v_1(x)) \\cdot v_2'(x) + \\frac{v_2(x)}{v_1(x)} \\cdot v_1'(x) \\right)\n\\end{align*}\n\nAuch hier sind alle nötigen Fehlerbehandlungen bereits in `math.pow` implementiert.\n\n:::{#exr-ImplementPow}\n\n## Den Operator `**` implementieren - Teil 1\n<br>\n\nErgänze die Datei `floatsad.py` mit der Methode `__pow__(self, other)`. Dabei übernimmt `self` die Rolle von $v_1$ in der obigen Herleitung und `other` entspricht $v_2$. Die Funktion $\\ln(\\ldots)$ heisst in Python `math.log()`.\nTeste dein Programm an verschiedenen Funktionen.\n\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndef __pow__(self, other):\n    if type(other) in (float, int):\n        newValue = math.pow(self.value, other)\n        newDerivative = other * math.pow(self.value, other - 1) * self.derivative\n    else:\n        newValue = math.pow(self.value, other.value)\n        newDerivative = math.pow(self.value, other.value) * \\\n            (other.derivative * math.log(self.value) + other.value * self.derivative / self.value)\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::\n\nNun implementieren wir auch noch die Methode `__rpow__(self, other)`. Im Fall, dass `type(other) in (float, int)` ist, handelt es sich hierbei um eine Exponentialfunktion. `math.pow` stellt dann sicher, dass die Basis, also `other`, eine positive Zahl ist.\nFalls `other` ebenfalls ein `FloatSad` ist, dann kann die Ableitung gleich wie oben berechnet werden, ausser, dass jetzt `self` und `other` ihre Rollen tauschen.\n\n:::{#exr-ImplementRpow}\n\n## Den Operator `**` implementieren - Teil 2\n<br>\n\nErgänze die Datei `floatsad.py` mit der Methode `__rpow__(self, other)`.\nTeste dein Programm an verschiedenen Funktionen.\n\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ndef __rpow__(self, other):\n    if type(other) in (float, int):\n        newValue = math.pow(other, self.value)\n        newDerivative = math.pow(other, self.value) * math.log(other) * self.derivative\n    else:\n        newValue = math.pow(other.value, self.value)\n        newDerivative = math.pow(other.value, self.value) * \\\n            (self.derivative * math.log(other.value) + self.value * other.derivative / other.value)\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::\n\n\n### Vergleichsoperatoren\n\nEs könnte sein, dass wir `FloatSad`-Objekte auch miteinander vergleichen wollen, also eine der Abfragen aus @tbl-Vergleichsmethoden machen wollen.\n\n| Operator | Methode                 |\n|----------|-------------------------|\n| `<`        | `__lt__(self, other)` |\n| `<=`       | `__le__(self, other)` |\n| `==`       | `__eq__(self, other)` |\n| `!=`       | `__ne__(self, other)` |\n| `>`        | `__gt__(self, other)` |\n| `>=`       | `__ge__(self, other)` |\n\n: Vergleichsoperatoren {#tbl-Vergleichsmethoden}\n\nDazu vergleichen wir jeweils nur die Funktionswerte. Die Implementation sieht dann folgendermassen aus:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Vergleichsoperatoren \n\ndef __lt__(self, other):\n    if type(other) in (float, int):\n        return self.value < other\n    else:\n        return self.value < other.value\n\ndef __le__(self, other):\n    if type(other) in (float, int):\n        return self.value <= other\n    else:\n        return self.value <= other.value\n\ndef __eq__(self, other):\n    if type(other) in (float, int):\n        return self.value == other\n    else:\n        return self.value == other.value\n\ndef __ne__(self, other):\n    if type(other) in (float, int):\n        return self.value != other\n    else:\n        return self.value != other.value\n\ndef __gt__(self, other):\n    if type(other) in (float, int):\n        return self.value > other\n    else:\n        return self.value > other.value\n\ndef __ge__(self, other):\n    if type(other) in (float, int):\n        return self.value >= other\n    else:\n        return self.value >= other.value\n```\n:::\n\n\n## Die Klasse `FloatSad` im Einsatz\n\n\n\nFalls im letzten Abschnitt etwas nicht geklappt haben sollte, kann die fertige Klasse `FloatSad` von [hier](floatsad.py) kopiert werden.\n\nUm unsere Klasse zu verwenden müssen wir sie jeweils am Anfang mit \n\n::: {.cell execution_count=26}\n``` {.python .cell-code code-fold=\"false\"}\nfrom floatsad import FloatSad\n```\n:::\n\n\neinbinden.\n\n:::{#exm-FloatSadUsage1}\n\n## Ein Programm mit FloatSad\n<br>\n\nBetrachte die Funktion aus @exm-FirstFunctionAsProgram. Wir übernehmen das Programm und passen lediglich die erste Zeile der Funktion gemäss der Konvention aus @sec-FoatSadClassDescription an.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code code-fold=\"show\"}\nfrom floatsad import FloatSad\n\ndef f(x):\n    v0 = FloatSad(x)\n    v1 = 2 + v0\n    v2 = v0 - 3\n    y = v1 * v2\n    return y\n\nx0 = 2\nprint(f(x0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n< -4.0 ; 3.0 >\n```\n:::\n:::\n\n\nDa nun alle Ableitungsregeln in den verwendeten Operatoren integriert sind, können wir sogar auf die Zwischenschritte mit den `v` verzichten:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code code-fold=\"show\"}\nfrom floatsad import FloatSad\n\ndef f(x):\n    x = FloatSad(x)\n    y = (2+x) * (x-3)\n    return y\n\nx0 = 2\nprint(f(x0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n< -4.0 ; 3.0 >\n```\n:::\n:::\n\n\n:::\n\n---\n\nWir sehen, dass wir also alle unsere Konventionen, die dazu dienten, komplizierte Funktionsausdrücke in ihre Bestandteile zu zerlegen und diese mit den elementaren Ableitungsregeln zu differenzieren, wieder aufgeben können! Der einzige Zusatzaufwand, den wir bei der Programmierung haben, ist das Umwandeln des Arguments `x` in ein `FloatSad`-Objekt.\n\n:::{#exr-FloatSadAnwenden1}\n\n## `FloatSad` anwenden\n<br>\n\nVereinfache die Lösung von @exr-SADmitSchleife mit Hilfe der Klasse `FloatSad`. Überzeuge dich davon, dass die Ableitungen auch für Programme mit Schleifen korrekt berechnet werden.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nfrom floatsad import FloatSad\n\ndef l(x):\n    y = x**2 + 1\n    return y\n\ndef f(x):\n    x = FloatSad(x)\n    for i in range(3):\n        x = l(x)\n    return x\n\nprint(f(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n< 26.0 ; 80.0 >\n```\n:::\n:::\n\n\n:::\n\n\n## Das Modul `mathsad`  {#sec-modulMathSad}\n\nMit der Klasse `FloatSad` können wir Funktionswerte und Ableitungen von algebraischen Funktionen bilden. Wir können aber unsere `FloatSad`-Objekte noch nicht mit den Funktionen aus dem Python-Modul `math` verwenden, z.B. mit `exp` oder `sin`. In diesem Abschnitt wollen wir ein eigenes Modul `mathsad` schreiben, in dem wir die Funktionen aus @tbl-mathFunctions so implementieren, dass wir sie auf `FloatSad`-Objekte anwenden können.\n\n|         |         |         |\n|:-------:|:-------:|:-------:|\n| `sqrt`  | `exp`   | `log`   |\n| `sin`   | `cos`   | `tan`   |\n| `asin`  | `acos`  | `atan`  |\n| `sinh`  | `cosh`  | `tanh`  |\n| `asinh` | `acosh` | `atanh` |\n| `fabs`  |         |         |\n\n: Funktionen des Moduls `math` (Auswahl) {#tbl-mathFunctions}\n\nGemäss der [Python-Dokumentation](https://docs.python.org/3.8/library/math.html) liefert die Funktion `math.exp(x)` präzisere Werte als `math.e ** x` oder `math.pow(math.e, x)`. Die Funktion `math.log(x)` berechnet den Logarithmus zur Basis $e$, man kann ihr aber als zweites Argument auch eine andere Basis übergeben, z.B. `math.log(x,b)`, was dann mit `math.log(x)/math.log(b)` berechnet wird. Die Funktion `math.fabs(x)` schliesslich berechnet den Absolutbetrag $|x|$. Ihre Ableitung ist\n\n::: {.cell execution_count=30}\n``` {.python .cell-code code-fold=\"false\"}\n(math.fabs(v)).derivative = v.derivative if v>=0 else -v.derivative\n```\n:::\n\n\nDie Funktion $y=|x|$ ist an der Stelle $x=0$ eigentlich nicht differenzierbar. Da wir aber nicht Ableitungsfunktionen, sondern nur Werte von Ableitungen an einer bestimmten Stelle berechnen, reicht es, den rechts- oder linksseitigen Grenzwert zurückzugeben, siehe @Gander1992. Wir müssen es dem Benutzer überlassen, das Ergebnis im jeweiligen Kontext korrekt zu interpretieren.\n\n### Die Funktion `sqrt`\n\nBeginnen wir mit der Implementierung der Wurzelfunktion.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code code-fold=\"show\"}\nimport math\nfrom floatsad import FloatSad\n\ndef sqrt(x):\n    newValue = math.sqrt(x.value)\n    newDerivative = 1/(2*math.sqrt(x.value)) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\nif __name__ == '__main__':\n\n    def f(x):\n        x = FloatSad(x)\n        y = 1 / sqrt(x**2 + 1)\n        return y\n\n    x0 = -1\n    print(f(x0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n< 0.7071067811865475 ; 0.3535533905932737 >\n```\n:::\n:::\n\n\nWir gehen davon aus, dass `x` ein `FloatSad`-Objekt ist. Für den Wert von `sqrt(x)` verwenden wir einfach die Funktion `math.sqrt`. Diese enthält auch die nötige Fehlerbehandlung. Zusätzlich berechnen wir aber noch den Wert der Ableitung mit Hilfe der bekannten Ableitungsregel und wie zuvor wenden wir immer die Kettenregel an. Das Programm enthält auch ein Testprogramm, welches die Ableitung der Funktion $f(x) = \\frac{1}{\\sqrt{x^2+1}}$ an der Stelle $x_0 = -1$ berechnet. Zur Kontrolle kann die GeoGebra-Vorlage zu Beginn von @sec-SadManualImplementation verwendet werden. \n\n### Die Funktionen `exp` und `log`\n\n:::{#exr-implementExp}\n\n## Exponentialfunktion\n<br>\n\nKopiere den obigen Code und speichere ihn in einer Datei mit dem Namen `mathsad.py`. Speichere die Datei im gleichen Ordner wie die anderen Dateien. Ergänze die Datei danach mit der Funktion `exp`. Wähle eine neue Testfunktion im `main`, um dich von der Richtigkeit deiner Lösung zu überzeugen. \n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ndef exp(x):\n    newValue = math.exp(x.value)\n    newDerivative = math.exp(x.value) * x.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::\n\nFür die Logarithmusfunktion müssen wir uns wieder etwas mehr Gedanken machen. Mit `def log(x, b = math.e)` kann man der Basis $b$ wie oben beschrieben den Standardwert $b=e$ geben. Solange `b` vom Typ `int` oder `float` ist, kann man einfach die bekannte Ableitungsregel anwenden.\nWenn aber `b` ein `FloatSad`-Objekt ist, wie z.B. in `v3 = math.log(v1, v2)`, dann müssen wir den Basiswechselsatz\n$$\nv_3(x) = \\log_{v_2(x)}(v_1(x)) = \\frac{\\ln(v_1(x))}{\\ln(v_2(x))}\n$$\nverwenden und mit der Quotientenregel ableiten.\n\n:::{#exr-implementLog}\n\n## Logarithmusfunktion\n<br>\n\nÜberlege dir, wie die Ableitung von $v_3(x)$ aussieht. Ergänze danach die Datei `mathsad.py` mit der Implementation der Logarithmusfunktion. Überzeuge dich mit einer Testfunktion von der Richtigkeit deines Programms.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\nDie Ableitung lautet\n$$\n\\frac{d}{dx}v_3(x) = \\frac{\\frac{v_1'(x)}{v_1(x)}\\cdot \\ln(v_2(x))-\\ln(v_1(x))\\cdot\\frac{v_2'(x)}{v_2(x)}}{\\ln^2(v_2(x))}\n$$\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\ndef log(x, b = math.e):\n    if type(b) in (float, int):\n        newValue = math.log(x.value, b)\n        newDerivative = 1 / (x.value * math.log(b)) * x.derivative\n    else:\n        newValue = math.log(x.value, b.value)\n        newDerivative = (x.derivative/x.value * math.log(b.value) - math.log(x.value) * b.derivative / b.value) \\\n            / math.pow(math.log(b.value), 2)\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::\n\n### Die trigonometrischen Funktionen und ihre Umkehrfunktionen\n\nBei den trigonometrischen Funktionen und den Arcus Funktionen können wir einfach die bekannten Ableitungsregeln verwenden.\n\n:::{#exr-implementTrig}\n\n## Trigonometrische Funktionen\n<br>\n\nErgänze die Datei `mathsad.py` mit den Funktionen `sin`, `cos` und `tan`, sowie den Funktionen `asin`, `acos` und `atan`.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\nBeachte, dass man für `tan` einfach $\\tan(x)=\\frac{\\sin(x)}{\\cos(x)}$ verwenden kann, wenn `sin` und `cos` bereits implementiert sind.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\ndef sin(x):\n    newValue = math.sin(x.value)\n    newDerivative = math.cos(x.value) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef cos(x):\n    newValue = math.cos(x.value)\n    newDerivative = -math.sin(x.value) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef tan(x):\n    return sin(x) / cos(x)\n\ndef asin(x):\n    newValue = math.asin(x.value)\n    newDerivative = 1/math.sqrt( 1 - math.pow(x.value, 2)) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef acos(x):\n    newValue = math.acos(x.value)\n    newDerivative = -1/math.sqrt( 1 - math.pow(x.value, 2)) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef atan(x):\n    newValue = math.atan(x.value)\n    newDerivative = 1/(math.pow(x.value, 2) + 1) * x.derivative\n    return FloatSad(newValue, newDerivative) \n```\n:::\n\n\n:::\n\n\n### Die hyperbolischen Funktionen und ihre Umkehrfunktionen\n\nAuch bei den hyperbolischen Funktionen und den Area Funktionen verwenden wir die bekannten Ableitungsregeln.\n\n:::{#exr-implementHyp}\n\n## Hyperbolische Funktionen\n<br>\n\nErgänze die Datei `mathsad.py` mit den Funktionen `sinh`, `cosh` und `tanh`, sowie den Funktionen `asinh`, `acosh` und `atanh`.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\nWie bei den trigonometrischen Funktionen gilt auch hier $\\tanh(x)=\\frac{\\sinh(x)}{\\cosh(x)}$.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\ndef sinh(x):\n    newValue = math.sinh(x.value)\n    newDerivative = math.cosh(x.value) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef cosh(x):\n    newValue = math.cosh(x.value)\n    newDerivative = math.sinh(x.value) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef tanh(x):\n    return sinh(x) / cosh(x)\n\ndef asinh(x):\n    newValue = math.asinh(x.value)\n    newDerivative = 1/math.sqrt(math.pow(x.value, 2) + 1) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef acosh(x):\n    newValue = math.acosh(x.value)\n    newDerivative = 1/math.sqrt(math.pow(x.value, 2) - 1) * x.derivative\n    return FloatSad(newValue, newDerivative)\n\ndef atanh(x):\n    newValue = math.atanh(x.value)\n    newDerivative = -1/(math.pow(x.value, 2) - 1) * x.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::\n\n### Die Betragsfunktion\n\nSchliesslich ergänzen wir die Datei `mathsad.py` noch mit der Funktion `fabs` wie oben beschrieben:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code code-fold=\"show\"}\ndef fabs(x):\n    newValue = math.fabs(x.value)\n    newDerivative = x.derivative if x>=0 else -x.derivative\n    return FloatSad(newValue, newDerivative)\n```\n:::\n\n\n:::{#exm-fabsMotivation}\n\n## Motivation für die Funktion fabs\n\nDieses Beispiel stammt aus @Griewank2008EDP, S. 24. \nDie Funktion $f(x) = \\sqrt{x^6} = |x|^3$ ist auch an der Stelle $x_0=0$ differenzierbar, aber die Wurzelfunktion wie auch die Betragsfunktion sind es nicht. Die folgenden Programme scheitern an dieser Schwierigkeit.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code code-fold=\"show\"}\nfrom floatsad import FloatSad\n\ndef f(x):\n    x = FloatSad(x)\n    v = x**6\n    y = v**0.5\n    return y\n\nx0 = 0\nprint(f(x0)) # math domain error\n```\n:::\n\n\nDer rationale Exponent (Wurzel) führt zu einem Fehler.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code code-fold=\"show\"}\nfrom floatsad import FloatSad\nimport mathsad\n\ndef g(x):\n    x = FloatSad(x)\n    v = x**6\n    y = mathsad.sqrt(v)\n    return Y\n\nx0 = 0\nprint(g(x0)) # float division by zero\n```\n:::\n\n\nDie Auswertung der Ableitung der Wurzelfunktion an der Stelle 0 erzeugt einen Fehler. Mit unserer Funktion `fabs` erhalten wir jedoch den korrekten Wert:\n\n::: {.cell execution_count=39}\n``` {.python .cell-code code-fold=\"show\"}\nfrom floatsad import FloatSad\nimport mathsad\n\ndef h(x):\n    x = FloatSad(x)\n    v = mathsad.fabs(x)\n    y = v**3\n    return y\n\nx0 = 0\nprint(h(x0)) # funktioniert\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n< 0.0 ; 0.0 >\n```\n:::\n:::\n\n\n:::\n---\n\nDas fertige Modul kann auch von [hier](mathsad.py) kopiert werden.\n\n\n## Das Modul `mathsad` im Einsatz\n\n\n\nNun können wir unser Modul mit \n\n::: {.cell execution_count=41}\n``` {.python .cell-code code-fold=\"false\"}\nimport mathsad\n```\n:::\n\n\neinbinden und verwenden. Die Funktion aus @exr-SAD1 beispielsweise können wir nun direkt hinschreiben:\n\n::: {.cell execution_count=42}\n``` {.python .cell-code code-fold=\"show\"}\nfrom floatsad import FloatSad\nimport mathsad\n\ndef f(x):\n    x = FloatSad(x)\n    y = mathsad.cos(x**2 + 2) * mathsad.exp(-1/2 * x**2) + 1/x\n    return y\n\nx0 = -2\nprint(f(x0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n< -0.3700550823007931 ; -0.14136926695938976 >\n```\n:::\n:::\n\n\n:::{#exr-mathsadAnwenden}\n\n## Verwendung von `mathsad`\n<br>\n\nVerwende das Modul `mathsad`, um die Lösung von @exr-SAD2 zu vereinfachen. Bestimme die Ableitung von $f$ an der Stelle $x_0=\\sqrt{2}$.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\nfrom floatsad import FloatSad\nimport math\nimport mathsad\n\ndef f(x):\n    x = FloatSad(x)\n    u = x**2 + 1\n    y = mathsad.log(u) / mathsad.sqrt(u + x)\n    return y\n\nx0 = math.sqrt(2)\nf0 = f(x0)\nprint(f0.derivative)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.22198842685304976\n```\n:::\n:::\n\n\n:::\n\n\n:::{#exr-billardMathsadSolutions}\n\n## Billard-Problem mit `mathsad`\n<br>\n\nVerwende das Modul `mathsad`, um die Lösung des Billard-Problems aus @exr-BillardSADmanualSOlution zu vereinfachen. Programmiere dazu nochmals die Funktion `f(x)`, aber verwende aussagekräfigere Variablen. Weil `f` nun `FloatSad`-Objekte zurückgibt, muss auch die Funktion `newton(f, x0)` angepasst werden. Die Funktion `main` kann aus der obigen Lösung kopiert werden.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\nIn der Funktion `newton(f, x0)` muss lediglich die Berechnung des neuen Näherungswertes angepasst werden durch `x1 = x0 - y0.value / y0.derivative`.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nfrom floatsad import FloatSad\nimport math\nimport mathsad\nimport matplotlib.pyplot as plt\n\ndef f(x):\n    # Parameter a, px, py werden im global space gefunden\n    x = FloatSad(x)\n    Xx, Xy = mathsad.cos(x), mathsad.sin(x) # Koordinaten von X\n    tx, ty = -Xy, Xx                        # Komponenten des Tangentialvektors\n    XPx, XPy = px - Xx, py - Xy             # Komponenten des Vektors XP\n    lXP = mathsad.sqrt(XPx**2 + XPy**2)     # Länge des Vektors XP\n    ePx, ePy = XPx / lXP, XPy / lXP         # Komponenten des Einheitsvektors in Richtung XP\n    XQx, XQy = a - Xx, -Xy                  # Komponenten des Vektors XQ\n    lXQ = mathsad.sqrt(XQx**2 + XQy**2)     # Länge des Vektors XQ\n    eQx, eQy = XQx / lXQ, XQy / lXQ         # Komponenten des Einheitsvektors in Richtung XQ\n    y = (ePx + eQx) * tx + (ePy + eQy) * ty # Skalarprodukt\n    return y\n\ndef newton(f, x0):\n    tol = 1e-8\n    y0 = f(x0)\n    x1 = x0 - y0.value / y0.derivative\n    while math.fabs(x1 - x0) > tol:\n        x0 = x1\n        y0 = f(x0)\n        x1 = x0 - y0.value / y0.derivative\n    return x1\n\n# Parameter definieren\na = -0.5          # Position von Q = (a|0)\npx, py = 0.2, 0.6 # Position von P = (px|py)\n# Lösung des Billardproblems berechnen\nsol = set({}) # leere Menge, in der die gefundenen Lösungen gespeichert werden\nX = [2*math.pi * k / 10 for k in range(10)]  # Liste der Startwerte für Newton\nfor x0 in X:\n    x = newton(f, x0)\n    sol.add(x)\n# Lösungen grafisch darstellen\nfig = plt.figure()\nax = plt.gca()\nax.set_xlim((-1.2, 1.2))\nax.set_ylim((-1.2, 1.2))\nax.set_aspect('equal')\ncircle = plt.Circle((0,0), 1, color='b', fill=False)\nqBall = plt.Circle((a,0), 0.02, color='k')\npBall = plt.Circle([px, py], 0.02, color='k')\nax.add_patch(circle)\nax.add_patch(qBall)\nax.add_patch(pBall)\nfor x in sol:\n    xcoords = [a, math.cos(x), px]\n    ycoords = [0, math.sin(x), py]\n    plt.plot(xcoords, ycoords, linewidth=1, linestyle='--')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Lösung des Billardproblems mit anderen Startwerten.](ADOneDimManually_files/figure-html/fig-billardproblemsolutionwithmathsad-output-1.png){#fig-billardproblemsolutionwithmathsad width=423 height=404}\n:::\n:::\n\n\n:::\n\n:::{#exr-minDistSolutionWithSAD}\n\n## Kürzeste Distanz mit `mathsad`\n<br>\n\nVerwende das Modul `mathsad`, um die Lösung von @exr-MinDistlSolution zu vereinfachen. Weil `d` nun `FloatSad`-Objekte zurückgibt, muss auch die Funktion `gradient_descent(f, x0, lam)` angepasst werden.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\nIn der Funktion `gradient_descent(f, x0, lam)` muss lediglich die Berechnung des neuen Näherungswertes angepasst werden. Statt des Graphen wird hier nur das globale Minimum als Punkt ausgegeben.\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nfrom floatsad import FloatSad\nimport math\nimport mathsad\n\ndef d(t):\n    t = FloatSad(t)\n    Px = 2 * mathsad.cos(t) - 1    # x-Koordinate von P\n    Py = 1.5 * mathsad.sin(t)      # y-Koordinate von P\n    Pz = 0                         # z-Koordinate von P\n    Qx = -3 * mathsad.sin(2*t)     # x-Koordinate von Q\n    Qy = 2 * mathsad.cos(2*t) + 1  # y-Koordinate von Q\n    Qz = 2 * mathsad.sin(2*t) + 1  # z-Koordinate von Q\n    y = mathsad.sqrt((Px-Qx)**2 + (Py-Qy)**2 + (Pz-Qz)**2)\n    return y\n\ndef gradient_descent(f, x0, lam):\n    tol = 1e-9\n    # Erster Schritt berechnen\n    y0 = f(x0)\n    x1 = x0 - lam * y0.derivative\n    while math.fabs(x1-x0) > tol:\n        x0 = x1\n        y0 = f(x0)\n        x1 = x0 - lam * y0.derivative\n    return x1\n\n\nt0 = 3\ntmin = gradient_descent(d, t0, 0.01)\ndmin = d(tmin)\nprint(\"Minimum bei (\", tmin, dmin.value, \")\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMinimum bei ( 4.712388977478413 1.5 )\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "ADOneDimManually_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}