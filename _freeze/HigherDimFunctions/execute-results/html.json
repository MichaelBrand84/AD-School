{
  "hash": "f6f1519da3803e14451560c53d625301",
  "result": {
    "markdown": "---\ntbl-cap-location: bottom\n---\n\n# Funktionen mit mehreren In- und Outputs\n\n\n\n\n\nWir wollen nun unsere Betrachtungen erweitern auf Funktionen, die zu einem Eingabewert mehrere Ausgabewerte produzieren, d.h. $f : \\mathbb{R}\\rightarrow\\mathbb{R}^m$ (Parameterkurven) oder aus mehreren Eingabewerten einen Ausgabewert berechnen, d.h. $f : \\mathbb{R}^n \\rightarrow\\mathbb{R}$ oder im allgemeinen Fall aus $n$ Eingabewerten $m$ Ausgabewerte berechnen, d.h. $f : \\mathbb{R}^n \\rightarrow\\mathbb{R}^m$.\n\n## Funktionen $\\mathbb{R}\\rightarrow\\mathbb{R}^m$\n\nEine vektorwertige Funktion $f : \\mathbb{R}\\rightarrow\\mathbb{R}^m$ mit\n\n$$\nf(t) = \\left( \\begin{align*} y_1 &(t) \\\\ &\\vdots \\\\ y_m &(t) \\end{align*}  \\right)\n$$\n\nkann man sich als eine Kurve in einem $m$-dimensionalen Raum vorstellen. Im Beispiel @exm-GDApplication wird beispielsweise die Bahn des Punktes $Q$ durch die Funktion\n\n$$\nf(t) = \\left( \\begin{align*} -3 &\\sin(2t) \\\\ 2 &\\cos(2t) + 1 \\\\ 2 &\\sin(2t) + 1 \\end{align*}  \\right)\n$$\n\nbeschrieben. Die Ableitung einer solchen Funktion wird komponentenweise berechnet und gibt zu einem bestimmten Zeitpunkt $t_0$ den Tangentialvektor im Kurvenpunkt $f(t_0)$ an:\n\n$$\ndf(t) = \\left( \\begin{align*} \\dot y_1 &(t) \\\\ &\\vdots \\\\ \\dot y_m &(t) \\end{align*}  \\right)\n$$\n\nPhysikalisch entspricht dies dem Geschwindigkeitsvektor zum Zeitpunkt $t_0$.\n\nAls Programm können wir die obige Kurve so darstellen\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"show\"}\nimport math\n\ndef f(t):\n    y1 = -3*math.sin(2*t)\n    y2 = 2*math.cos(2*t) + 1\n    y3 = 2*math.sin(2*t) + 1\n    y = [y1, y2, y3]\n    return y\n\nt0 = 2\ny0 = f(t0)\nprint(y0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2.2704074859237844, -0.3072872417272239, -0.5136049906158564]\n```\n:::\n:::\n\n\nFür die Ableitung können wir unser Modul `FloatSad` benutzen. Der Rückgabewert der Funktion ist dann ein Array mit drei `FloatSad`-Objekten.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"show\"}\nfrom floatsad import FloatSad \nimport mathsad\n\ndef f(t):\n    t = FloatSad(t)\n    y1 = -3*mathsad.sin(2*t)\n    y2 = 2*mathsad.cos(2*t) + 1\n    y3 = 2*mathsad.sin(2*t) + 1\n    y = [y1, y2, y3]\n    return y\n\nt0 = 2\ny0 = f(t0)\nprint(\"y1(\" + str(t0) + \") = \" + str(y0[0].value))\nprint(\"y1'(\" + str(t0) + \") = \" + str(y0[0].derivative))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny1(2) = 2.2704074859237844\ny1'(2) = 3.921861725181672\n```\n:::\n:::\n\n\nDiese Implementation hat den Nachteil, dass die Handhabung etwas kompliziert wird. Insbesondere kann man nicht einfach `y0.value` schreiben, um eine Liste der Funktionswerte zu erhalten. Abhilfe schafft dabei das Modul `numpy` und die Vektorisierung der Funktion:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"show\"}\nfrom floatsad import FloatSad\nimport mathsad\nimport numpy as np\n\n@np.vectorize\ndef f(t):\n    t = FloatSad(t)\n    y1 = -3*mathsad.sin(2*t)\n    y2 = 2*mathsad.cos(2*t) + 1\n    y3 = 2*mathsad.sin(2*t) + 1\n    y = [y1, y2, y3]\n    return y\n\ngetValues = np.vectorize(lambda y : y.value)\ngetDerivatives = np.vectorize(lambda y : y.derivative)\n\nt0 = 2\ny0 = f(t0)\nprint(getValues(y0))\nprint(getDerivatives(y0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 2.27040749 -0.30728724 -0.51360499]\n[ 3.92186173  3.02720998 -2.61457448]\n```\n:::\n:::\n\n\n## Funktionen $f : \\mathbb{R}^n \\rightarrow\\mathbb{R}^m$\n\n",
    "supporting": [
      "HigherDimFunctions_files"
    ],
    "filters": [],
    "includes": {}
  }
}