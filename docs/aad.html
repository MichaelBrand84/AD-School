<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>AutoDiff - 5&nbsp; Adjungierte Algorithmische Differentiation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./HigherDimFunctions.html" rel="prev">
<link href="./mycover.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Adjungierte Algorithmische Differentiation</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./mycover.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">AutoDiff</a> 
        <div class="sidebar-tools-main">
    <a href="./AutoDiff.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Vorwort</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Ableitungen und ihre Anwendungen</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./notAD.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">AD ist nicht …</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ADOneDimManually.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Standard Algorithmische Differentiation für eindimensionale Funktionen</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./HigherDimFunctions.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Funktionen mit mehreren In- und Outputs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./aad.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Adjungierte Algorithmische Differentiation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">References</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#manuelle-implementation-der-aad" id="toc-manuelle-implementation-der-aad" class="nav-link active" data-scroll-target="#manuelle-implementation-der-aad"><span class="toc-section-number">5.1</span>  Manuelle Implementation der AAD</a></li>
  <li><a href="#implementation-der-aad-mit-operator-overloading" id="toc-implementation-der-aad-mit-operator-overloading" class="nav-link" data-scroll-target="#implementation-der-aad-mit-operator-overloading"><span class="toc-section-number">5.2</span>  Implementation der AAD mit Operator Overloading</a>
  <ul class="collapse">
  <li><a href="#die-klasse-floataad" id="toc-die-klasse-floataad" class="nav-link" data-scroll-target="#die-klasse-floataad"><span class="toc-section-number">5.2.1</span>  Die Klasse <code>FloatAad</code></a></li>
  <li><a href="#vorzeichen" id="toc-vorzeichen" class="nav-link" data-scroll-target="#vorzeichen"><span class="toc-section-number">5.2.2</span>  Vorzeichen</a></li>
  <li><a href="#die-operatoren-und--" id="toc-die-operatoren-und--" class="nav-link" data-scroll-target="#die-operatoren-und--"><span class="toc-section-number">5.2.3</span>  Die Operatoren <code>+</code> und <code>-</code></a></li>
  <li><a href="#gradienten-berechnen" id="toc-gradienten-berechnen" class="nav-link" data-scroll-target="#gradienten-berechnen"><span class="toc-section-number">5.2.4</span>  Gradienten berechnen</a></li>
  <li><a href="#die-operatoren-und" id="toc-die-operatoren-und" class="nav-link" data-scroll-target="#die-operatoren-und"><span class="toc-section-number">5.2.5</span>  Die Operatoren <code>*</code> und <code>/</code></a></li>
  <li><a href="#der-operator" id="toc-der-operator" class="nav-link" data-scroll-target="#der-operator"><span class="toc-section-number">5.2.6</span>  Der Operator <code>**</code></a></li>
  </ul></li>
  <li><a href="#die-klasse-floataad-im-einsatz" id="toc-die-klasse-floataad-im-einsatz" class="nav-link" data-scroll-target="#die-klasse-floataad-im-einsatz"><span class="toc-section-number">5.3</span>  Die Klasse <code>FloatAad</code> im Einsatz</a>
  <ul class="collapse">
  <li><a href="#gradient-descent-zum-auffinden-lokaler-minima" id="toc-gradient-descent-zum-auffinden-lokaler-minima" class="nav-link" data-scroll-target="#gradient-descent-zum-auffinden-lokaler-minima"><span class="toc-section-number">5.3.1</span>  Gradient Descent zum Auffinden lokaler Minima</a></li>
  <li><a href="#lineare-regression" id="toc-lineare-regression" class="nav-link" data-scroll-target="#lineare-regression"><span class="toc-section-number">5.3.2</span>  Lineare Regression</a></li>
  <li><a href="#bilder-schärfen" id="toc-bilder-schärfen" class="nav-link" data-scroll-target="#bilder-schärfen"><span class="toc-section-number">5.3.3</span>  Bilder schärfen</a></li>
  </ul></li>
  <li><a href="#sec-modulMathAad" id="toc-sec-modulMathAad" class="nav-link" data-scroll-target="#sec-modulMathAad"><span class="toc-section-number">5.4</span>  Das Modul <code>mathaad</code></a></li>
  <li><a href="#das-modul-mathaad-im-einsatz" id="toc-das-modul-mathaad-im-einsatz" class="nav-link" data-scroll-target="#das-modul-mathaad-im-einsatz"><span class="toc-section-number">5.5</span>  Das Modul <code>mathaad</code> im Einsatz</a>
  <ul class="collapse">
  <li><a href="#ein-einaches-neuronales-netz-zur-klassifikation-von-lilien" id="toc-ein-einaches-neuronales-netz-zur-klassifikation-von-lilien" class="nav-link" data-scroll-target="#ein-einaches-neuronales-netz-zur-klassifikation-von-lilien"><span class="toc-section-number">5.5.1</span>  Ein einaches neuronales Netz zur Klassifikation von Lilien</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-AAD" class="quarto-section-identifier d-none d-lg-block"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Adjungierte Algorithmische Differentiation</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>In <a href="HigherDimFunctions.html"><span>Kapitel&nbsp;4</span></a> haben wir gesehen, dass wir mit der Standard Algorithmischen Differentiation (SAD) alle <span class="math inline">\(m\)</span> Ableitungen einer Funktion <span class="math inline">\(f : \mathbb{R} \rightarrow \mathbb{R}^m\)</span> mit einem einzigen Funktionsaufruf berechnen können. Die Berechnung des Gradienten einer Funktion <span class="math inline">\(f : \mathbb{R}^n \rightarrow \mathbb{R}\)</span> benötigt jedoch <span class="math inline">\(n\)</span> Funktionsaufrufe, nämlich einen für jede partielle Ableitung <span class="math inline">\(\partial f / \partial x_i\)</span>. In diesem Kapitel wollen wir eine Methode entwickeln, die alle <span class="math inline">\(n\)</span> partiellen Ableitungen in einem Funktionsaufruf berechnet.</p>
<div class="page-columns page-full"><p>Ähnlich wie die SAD beruht auch diese Methode darauf, dass wir eine komplizierte Funktion schrittweise mit Hilfe von elementaren Operationen berechnen und in jedem Schritt die Ableitungen in separaten Variablen akkumulieren. Wir führen also wieder unsere Konvention aus Kapitel <a href="intro.html#sec-ProgFunc"><span>Kapitel&nbsp;1.2</span></a> ein. Auch dieses Mal werden wir in jedem Schritt die Kettenregel verwenden. Diesmal fangen wir jedoch am Ende der Funktion an und werden uns dann rückwärts durch alle Ableitungen arbeiten. Aus diesem Grund wird das Verfahren auch Rückwärts-AD <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> oder Adjungierte AD (AAD) genannt.</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;Im Englischen spricht man von <em>reverse mode differentiation</em> weil <em>backward differentiation</em> für bestimmte Methoden zur Integration von Differentialgleichungen verwendet wird.</p></li></div></div>
<section id="manuelle-implementation-der-aad" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="manuelle-implementation-der-aad"><span class="header-section-number">5.1</span> Manuelle Implementation der AAD</h2>
<p>Wir erläutern die Methode zuerst an einem einfachen Beispiel, welches eine leicht abgeänderte Version des Beispiels von <span class="citation" data-cites="sidsite2021">Radcliffe (<a href="references.html#ref-sidsite2021" role="doc-biblioref">2021</a>)</span> ist.</p>
<div id="exm-firstAADbyHand" class="theorem example">
<p><span class="theorem-title"><strong>Beispiel 5.1 (Gradient mit AAD) </strong></span><br></p>
<p>Betrachten wir die Funktion <span class="math inline">\(f : \mathbb{R}^2 \rightarrow \mathbb{R}\)</span> <span class="math display">\[
y = f(x_0, x_1) = (x_0 + x_1) \cdot x_0 - x_1
\]</span></p>
<p>Als Programm können wir die Funktion unter Berücksichtigung der Konvention so schreiben (siehe auch <a href="#fig-compTreeMulti">Abbildung&nbsp;<span>5.1</span></a>):</p>
<div class="cell" data-execution_count="1">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x0, x1):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    v0 <span class="op">=</span> x0</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    v1 <span class="op">=</span> x1</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    v2 <span class="op">=</span> v0 <span class="op">+</span> v1</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    v3 <span class="op">=</span> v2 <span class="op">*</span> v0</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    v4 <span class="op">=</span> v3 <span class="op">-</span> v1</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> v4</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>x0, x1 <span class="op">=</span> <span class="dv">2</span>, <span class="dv">3</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>y0 <span class="op">=</span> f(x0, x1)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"f("</span> <span class="op">+</span> <span class="bu">str</span>(x0) <span class="op">+</span> <span class="st">","</span> <span class="op">+</span> <span class="bu">str</span>(x1) <span class="op">+</span> <span class="st">") = "</span> <span class="op">+</span> <span class="bu">str</span>(y0))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>f(2,3) = 7</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-compTreeMulti" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p>
<svg width="672" height="480" viewbox="0.00 0.00 229.21 58.20" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 54.2)"> <polygon fill="white" stroke="transparent" points="-4,4 -4,-54.2 225.21,-54.2 225.21,4 -4,4"></polygon> <!-- nx0 --> <g id="node1" class="node">
<title>
nx0
</title>
<text text-anchor="start" x="3" y="-41.8" font-family="Cambria" font-size="8.00">x</text> <text text-anchor="start" x="7" y="-41.8" font-family="Cambria" baseline-shift="sub" font-size="8.00">0</text> </g> <!-- nPlus --> <g id="node3" class="node">
<title>
nPlus
</title>
<ellipse fill="none" stroke="black" cx="58.2" cy="-26.2" rx="8.41" ry="8.41"></ellipse> <text text-anchor="middle" x="58.2" y="-23.8" font-family="Cambria" font-size="8.00">+</text> </g> <!-- nx0&#45;&gt;nPlus --> <g id="edge1" class="edge">
<title>
nx0-&gt;nPlus
</title>
<path fill="none" stroke="black" d="M14.03,-41.12C22.45,-38.21 37.82,-32.9 47.76,-29.46"></path> <polygon fill="black" stroke="black" points="48.09,-30.28 50.17,-28.63 47.52,-28.62 48.09,-30.28"></polygon> </g> <!-- nTimes --> <g id="node4" class="node">
<title>
nTimes
</title>
<ellipse fill="none" stroke="black" cx="110.61" cy="-26.2" rx="8.41" ry="8.41"></ellipse> <text text-anchor="middle" x="110.61" y="-23.8" font-family="Cambria" font-size="8.00">*</text> </g> <!-- nx0&#45;&gt;nTimes --> <g id="edge3" class="edge">
<title>
nx0-&gt;nTimes
</title>
<path fill="none" stroke="black" d="M14.21,-43.95C24.96,-45.09 47.68,-46.75 66.4,-43.2 78.75,-40.86 92.08,-35.07 100.62,-30.9"></path> <polygon fill="black" stroke="black" points="101.26,-31.55 103.1,-29.66 100.48,-29.99 101.26,-31.55"></polygon> </g> <!-- nx1 --> <g id="node2" class="node">
<title>
nx1
</title>
<text text-anchor="start" x="3" y="-7.8" font-family="Cambria" font-size="8.00">x</text> <text text-anchor="start" x="7" y="-7.8" font-family="Cambria" baseline-shift="sub" font-size="8.00">1</text> </g> <!-- nx1&#45;&gt;nPlus --> <g id="edge2" class="edge">
<title>
nx1-&gt;nPlus
</title>
<path fill="none" stroke="black" d="M14.03,-11.29C22.45,-14.2 37.82,-19.5 47.76,-22.94"></path> <polygon fill="black" stroke="black" points="47.52,-23.78 50.17,-23.77 48.09,-22.13 47.52,-23.78"></polygon> </g> <!-- nMinus --> <g id="node5" class="node">
<title>
nMinus
</title>
<ellipse fill="none" stroke="black" cx="163.01" cy="-8.2" rx="8.41" ry="8.41"></ellipse> <text text-anchor="middle" x="163.01" y="-5.8" font-family="Cambria" font-size="8.00">-</text> </g> <!-- nx1&#45;&gt;nMinus --> <g id="edge5" class="edge">
<title>
nx1-&gt;nMinus
</title>
<path fill="none" stroke="black" d="M14.23,-9.16C37.89,-9.01 122.34,-8.46 151.79,-8.27"></path> <polygon fill="black" stroke="black" points="151.97,-9.14 154.47,-8.25 151.96,-7.39 151.97,-9.14"></polygon> </g> <!-- nPlus&#45;&gt;nTimes --> <g id="edge4" class="edge">
<title>
nPlus-&gt;nTimes
</title>
<path fill="none" stroke="black" d="M66.64,-26.2C75.28,-26.2 89.58,-26.2 99.28,-26.2"></path> <polygon fill="black" stroke="black" points="99.64,-27.08 102.14,-26.2 99.64,-25.33 99.64,-27.08"></polygon> </g> <!-- nTimes&#45;&gt;nMinus --> <g id="edge6" class="edge">
<title>
nTimes-&gt;nMinus
</title>
<path fill="none" stroke="black" d="M118.62,-23.7C127.49,-20.53 142.82,-15.06 152.68,-11.53"></path> <polygon fill="black" stroke="black" points="153,-12.35 155.06,-10.68 152.41,-10.7 153,-12.35"></polygon> </g> <!-- ny --> <g id="node6" class="node">
<title>
ny
</title>
<text text-anchor="middle" x="214.21" y="-5.8" font-family="Cambria" font-size="8.00">y</text> </g> <!-- nMinus&#45;&gt;ny --> <g id="edge7" class="edge">
<title>
nMinus-&gt;ny
</title>
<path fill="none" stroke="black" d="M171.27,-8.2C180.09,-8.2 194.96,-8.2 204.42,-8.2"></path> <polygon fill="black" stroke="black" points="204.67,-9.08 207.17,-8.2 204.67,-7.33 204.67,-9.08"></polygon> </g> </g>
</svg>
</p>
<p></p><figcaption class="figure-caption">Abbildung&nbsp;5.1: Computational Graph für <code>y = (x0 + x1) * x0 - x1</code>.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Die partiellen Ableitungen von <span class="math inline">\(f\)</span> lauten <span class="math display">\[
\begin{align*}
    \frac{\partial y}{\partial x_0} &amp;= \frac{\partial f}{\partial x_0} = (1+0)\cdot x_0 + (x_0 + x_1)\cdot 1 - 0=2x_0 + x_1 \\
    \frac{\partial y}{\partial x_1} &amp;= \frac{\partial f}{\partial x_1} = (0 + 1)\cdot x_0 - 1 = x_0 - 1
\end{align*}
\]</span> wobei für die Ableitung nach <span class="math inline">\(x_0\)</span> die Produktregel verwendet wurde. Die partielle Ableitung <span class="math inline">\(\partial y / \partial x_0\)</span> können wir auch berechnen, indem wir bei <span class="math inline">\(y = v_4\)</span> anfangen und jeweils die Definition der Hilfsvariablen einsetzen: <span class="math display">\[
\begin{align*}
    \frac{\partial y}{\partial x_0} &amp;= \frac{\partial v_4}{\partial x_0} \\
    &amp;= \frac{\partial (v_3 - v_1)}{\partial x_0} \\
    &amp;= \frac{\partial v_3}{\partial x_0} - \frac{\partial v_1}{\partial x_0} \\
    &amp;= \frac{\partial (v_2 \cdot v_0)}{\partial x_0} - \frac{\partial x_1}{\partial x_0} \\
    &amp;= \frac{\partial v_2}{\partial x_0} \cdot v_0 + v_2 \cdot \frac{\partial v_0}{\partial x_0} - 0 \\
    &amp;= \frac{\partial (v_0 + v_1)}{\partial x_0} \cdot v_0 + v_2 \cdot \frac{\partial x_0}{\partial x_0} \\
    &amp;= \left( \frac{\partial v_0}{\partial x_0} + \frac{\partial v_1}{\partial x_0} \right) \cdot x_0 + (v_0 + v_1) \cdot 1 \\
    &amp;= \left( \frac{\partial x_0}{\partial x_0} + \frac{\partial x_1}{\partial x_0} \right) \cdot x_0 + (x_0 + x_1) \\
    &amp;= (1 + 0) \cdot x_0 + (x_0 + x_1) \\
    &amp;= 2x_0 + x_1   
\end{align*}
\]</span></p>
<p>Analog findet man <span class="math inline">\(\partial y / \partial x_1\)</span> (diesmal lassen wir einige der offensichtlicheren Zwischenschritte weg): <span class="math display">\[
\begin{align*}
    \frac{\partial y}{\partial x_1} &amp;= \frac{\partial v_4}{\partial x_1} \\
    &amp;= \frac{\partial v_3}{\partial x_1} - \frac{\partial v_1}{\partial x_1} \\
    &amp;= \frac{\partial (v_2 \cdot v_0)}{\partial x_1} - 1 \\
    &amp;= \frac{\partial v_2}{\partial x_1} \cdot v_0 + v_2 \cdot \frac{\partial v_0}{\partial x_1} - 1 \\
    &amp;= \frac{\partial (v_0 + v_1)}{\partial x_1} \cdot x_0 + v_2 \cdot 0 - 1 \\
    &amp;= \left( \frac{\partial v_0}{\partial x_1} + \frac{\partial v_1}{\partial x_1} \right) \cdot x_0 - 1 \\
    &amp;= ( 0 + 1) \cdot x_0 - 1 \\
    &amp;= x_0 - 1   
\end{align*}
\]</span></p>
<p>Um die beiden Rechnungen zusammenzufassen, führen nun für jede Hilfsvariable <span class="math inline">\(v_i\)</span> eine neue Variable <span class="math inline">\(\bar v_i\)</span> ein, welche definiert ist als <span class="math display">\[
\bar v_i = \frac{\partial y}{\partial v_i}
\]</span> Ähnlich wie die <span class="math inline">\(\dot v_i\)</span> aus der SAD speichern diese Variablen die Werte der Ableitungen. Die neue Notation soll anzeigen, dass es sich um die AAD Methode handelt. Unser Ziel ist es also, <span class="math inline">\(\bar v_0 = \partial y / \partial v_0 = \partial y / \partial x_0\)</span> und <span class="math inline">\(\bar v_1 = \partial y / \partial v_1 = \partial y / \partial x_1\)</span> zu bestimmen. Beginnen wir in der letzten Zeile des Programms, dann gilt offenbar immer <span class="math inline">\(\bar v_4 = \partial y / \partial v_4 = 1\)</span>. In der Zeile darüber können wir <span class="math inline">\(\bar v_3\)</span> und <span class="math inline">\(\bar v_1\)</span> berechnen, indem wir die Kettenregel verwenden.</p>
<p><span class="math display">\[\begin{align*}
    \bar v_3 &amp;= \frac{\partial y}{\partial v_3} = \frac{\partial y}{\partial v_4} \cdot \frac{\partial v_4}{\partial v_3} = \bar v_4 \cdot (1-0)=\bar v_4  \\

    \bar v_1 &amp;= \frac{\partial y}{\partial v_1} = \frac{\partial y}{\partial v_4} \cdot \frac{\partial v_4}{\partial v_1} = \bar v_4 \cdot (0-1)= -\bar v_4
\end{align*}\]</span></p>
<p>Also sind <span class="math inline">\(\bar v_3 = 1\)</span> und <span class="math inline">\(\bar v_1 = -1\)</span>. Der Zwischenwert in <span class="math inline">\(\bar v_1\)</span> wird später ergänzt werden. Aus der Zeile <span class="math inline">\(v_3 = v_2 \cdot v_0\)</span> lassen sich als nächstes Ausdrücke für <span class="math inline">\(\bar v_2\)</span> und <span class="math inline">\(\bar v_0\)</span> finden.</p>
<p><span class="math display">\[\begin{align*}
    \bar v_2 &amp;= \frac{\partial y}{\partial v_2} = \frac{\partial y}{\partial v_3} \cdot \frac{\partial v_3}{\partial v_2} = \bar v_3 \cdot v_0 \\

    \bar v_0 &amp;= \frac{\partial y}{\partial v_0} = \frac{\partial y}{\partial v_3} \cdot \frac{\partial v_3}{\partial v_0} = \bar v_3 \cdot v_2
\end{align*}\]</span></p>
<p>Mit den vorher berechneten Werten erhalten wir also <span class="math inline">\(\bar v_2 = v_0\)</span> und <span class="math inline">\(\bar v_0 = v_2\)</span>. Beide Werte sind durch die Funktion bereits berechnet worden. Im obigen Beispiel gilt etwa <code>v0 = x0 = 2</code> und <code>v2 = x0 + x1 = 5</code>. Auch diese Zwischenwerte werden im nächsten Schritt ergänzt. Aus der Zeile <span class="math inline">\(v_2 = v_0 + v_1\)</span> ergibt sich nämlich</p>
<p><span class="math display">\[\begin{align*}
    \bar v_0 &amp;= \bar v_0 + \frac{\partial y}{\partial v_0} = \bar v_0 + \frac{\partial y}{\partial v_2} \cdot \frac{\partial v_2}{\partial v_0} \\
    &amp;= \bar v_0 + \bar v_2 \cdot (1+0) = \bar v_0 + \bar v_2 \\ &amp; \\

    \bar v_1 &amp;= \bar v_1 + \frac{\partial y}{\partial v_1} = \bar v_1 + \frac{\partial y}{\partial v_2} \cdot \frac{\partial v_2}{\partial v_1} \\
    &amp;= \bar v_1 + \bar v_2 \cdot (0+1) = \bar v_1 + \bar v_2
\end{align*}\]</span></p>
<p>Mit den bereits bekannten Werten erhalten wir <span class="math inline">\(\bar v_0 = v_2 + v_0\)</span> (bzw. mit den konkreten Werten des Beispiels <code>v0bar = 5 + 2</code>) und <span class="math inline">\(\bar v_1 = -1 + v_0\)</span> (bzw. <code>v1bar = -1 + 2</code>). Nun enthalten die Variablen <span class="math inline">\(\bar v_0\)</span> und <span class="math inline">\(\bar v_1\)</span> die Werte der gewünschten Ableitungen, nämlich <span class="math inline">\(\bar v_0 = (v_0 + v_1) + v_0 = 2x_0 + x_1\)</span> und <span class="math inline">\(\bar v_1 = -1 + x_0\)</span>. Wir können aber die letzten Schritte analog zu den vorherigen ausführen:</p>
<p><span class="math display">\[\begin{align*}
    \bar x_1 &amp;= \frac{\partial y}{\partial x_1} = \frac{\partial y}{\partial v_1} \cdot \frac{\partial v_1}{\partial x_1} = \bar v_1 \cdot 1  \\

    \bar x_0 &amp;= \frac{\partial y}{\partial x_0} = \frac{\partial y}{\partial v_0} \cdot \frac{\partial v_0}{\partial x_0} = \bar v_0 \cdot 1  \\
\end{align*}\]</span></p>
<p>Die Schwierigkeit besteht darin, dass wir nicht wie bei der SAD in jedem Schritt die Variable <span class="math inline">\(v_i\)</span> und gleichzeitig die Variable <span class="math inline">\(\dot v_i\)</span> berechnen können. Um die <span class="math inline">\(\bar v_i\)</span> zu bestimmen muss man zuerst die Funktion komplett ausführen, und sich dabei den Aufbau des Computational Graph merken. Erst dann kann man rückwärts die Ableitungswerte berechnen, angefangen bei der letzten Hilfsvariablen <span class="math inline">\(\bar v_4 = 1\)</span>. Das folgende Schema fasst die obigen Rechnungen zusammen.</p>
<p><span class="math display">\[\begin{equation*}
\left \downarrow
    \begin{aligned}[c]
        v_0 &amp;= x_0 \\
        v_1 &amp;= x_1 \\
        v_2 &amp;= v_0 + v_1 \\
        v_3 &amp;= v_2 \cdot v_0 \\
        v_4 &amp;= v_3 - v_1 \\
        y &amp;= v_4
    \end{aligned}  
\right .

\qquad

\begin{aligned}[c]
    &amp; \\
    &amp; \\
    &amp; \\
    &amp; \\
    &amp; \\
    &amp;\longrightarrow
\end{aligned}  

\qquad

\left \uparrow
    \begin{aligned}[c]
        \bar x_0 &amp;= \bar v_0 = 2\cdot x_0 + x_1 \\
        \bar x_1 &amp;= \bar v_1 = -1 + x_0 \\
        \bar v_0 &amp;= \bar v_0 + \bar v_2, \quad \bar v_1 = \bar v_1 + \bar v_2 \\
        \bar v_2 &amp;= \bar v_3 \cdot v_0, \quad \bar v_0 = \bar v_3 \cdot v_2 \\
        \bar v_3 &amp;= \bar v_4, \quad \bar v_1 = -\bar v_4 \\
        \bar v_4 &amp;= \bar y = 1
    \end{aligned}  
\right .
\end{equation*}\]</span></p>
<div class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x0, x1):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    v0 <span class="op">=</span> x0</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    v1 <span class="op">=</span> x1</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    v2 <span class="op">=</span> v0 <span class="op">+</span> v1</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    v3 <span class="op">=</span> v2 <span class="op">*</span> v0</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    v4 <span class="op">=</span> v3 <span class="op">-</span> v1</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> v4</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    v4bar <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    v3bar <span class="op">=</span> v4bar</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    v1bar <span class="op">=</span> <span class="op">-</span>v4bar</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    v2bar <span class="op">=</span> v3bar <span class="op">*</span> v0</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    v0bar <span class="op">=</span> v3bar <span class="op">*</span> v2</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    v0bar <span class="op">=</span> v0bar <span class="op">+</span> v2bar</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    v1bar <span class="op">=</span> v1bar <span class="op">+</span> v2bar</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    grad <span class="op">=</span> [v0bar, v1bar]</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [y, grad]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>x0, x1 <span class="op">=</span> <span class="dv">2</span>, <span class="dv">3</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>[y0, dy] <span class="op">=</span> f(x0, x1)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Funktionswert: "</span> <span class="op">+</span> <span class="bu">str</span>(y0))</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Gradient: "</span> <span class="op">+</span> <span class="bu">str</span>(dy))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Funktionswert: 7
Gradient: [7, 1]</code></pre>
</div>
</div>
<p>Die Werte der Ableitungen <span class="math inline">\(\bar v_i\)</span> lassen sich auch im Computational Graph verfolgen, siehe <a href="#fig-compTreeMultiReversed">Abbildung&nbsp;<span>5.2</span></a>. Der Wert bei der Kante von <span class="math inline">\(v_i\)</span> nach <span class="math inline">\(v_j\)</span> entspricht der partiellen Ableitung <span class="math inline">\(\partial v_i / \partial v_j\)</span>. Entlang eines Weges werden die Werte multipliziert. Führen mehrere Wege zu einer Variablen <span class="math inline">\(x_i\)</span>, so werden die Werte der einzelnen Wege addiert.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-compTreeMultiReversed" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p>
<svg width="672" height="480" viewbox="0.00 0.00 229.21 59.60" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 55.6)"> <polygon fill="white" stroke="transparent" points="-4,4 -4,-55.6 225.21,-55.6 225.21,4 -4,4"></polygon> <!-- nx0 --> <g id="node1" class="node">
<title>
nx0
</title>
<text text-anchor="start" x="3" y="-43.2" font-family="Cambria" font-size="8.00">x</text> <text text-anchor="start" x="7" y="-43.2" font-family="Cambria" baseline-shift="sub" font-size="8.00">0</text> </g> <!-- nPlus --> <g id="node3" class="node">
<title>
nPlus
</title>
<ellipse fill="none" stroke="black" cx="58.2" cy="-27.6" rx="8.41" ry="8.41"></ellipse> <text text-anchor="middle" x="58.2" y="-25.2" font-family="Cambria" font-size="8.00">+</text> </g> <!-- nx0&#45;&gt;nPlus --> <g id="edge1" class="edge">
<title>
nx0-&gt;nPlus
</title>
<path fill="none" stroke="red" d="M16.8,-41.56C26.35,-38.26 41.38,-33.07 50.17,-30.03"></path> <polygon fill="red" stroke="red" points="16.11,-40.87 14.03,-42.52 16.68,-42.53 16.11,-40.87"></polygon> <text text-anchor="middle" x="30.07" y="-29.09" font-family="Cambria" font-size="8.00" fill="red">1</text> </g> <!-- nTimes --> <g id="node4" class="node">
<title>
nTimes
</title>
<ellipse fill="none" stroke="black" cx="110.61" cy="-27.6" rx="8.41" ry="8.41"></ellipse> <text text-anchor="middle" x="110.61" y="-25.2" font-family="Cambria" font-size="8.00">*</text> </g> <!-- nx0&#45;&gt;nTimes --> <g id="edge3" class="edge">
<title>
nx0-&gt;nTimes
</title>
<path fill="none" stroke="red" d="M16.94,-45.62C28.48,-46.72 49.14,-47.87 66.4,-44.6 80.03,-42.02 94.85,-35.23 103.1,-31.06"></path> <polygon fill="red" stroke="red" points="16.78,-44.73 14.21,-45.35 16.61,-46.47 16.78,-44.73"></polygon> <text text-anchor="start" x="66.42" y="-38.4" font-family="Cambria" font-size="8.00" fill="red">v</text> <text text-anchor="start" x="70.42" y="-38.4" font-family="Cambria" baseline-shift="sub" font-size="8.00" fill="red">2</text> </g> <!-- nx1 --> <g id="node2" class="node">
<title>
nx1
</title>
<text text-anchor="start" x="3" y="-9.2" font-family="Cambria" font-size="8.00">x</text> <text text-anchor="start" x="7" y="-9.2" font-family="Cambria" baseline-shift="sub" font-size="8.00">1</text> </g> <!-- nx1&#45;&gt;nPlus --> <g id="edge2" class="edge">
<title>
nx1-&gt;nPlus
</title>
<path fill="none" stroke="red" d="M16.8,-13.64C26.35,-16.94 41.38,-22.13 50.17,-25.17"></path> <polygon fill="red" stroke="red" points="16.68,-12.67 14.03,-12.68 16.11,-14.33 16.68,-12.67"></polygon> <text text-anchor="middle" x="30.07" y="-11.71" font-family="Cambria" font-size="8.00" fill="red">1</text> </g> <!-- nMinus --> <g id="node5" class="node">
<title>
nMinus
</title>
<ellipse fill="none" stroke="black" cx="163.01" cy="-9.6" rx="8.41" ry="8.41"></ellipse> <text text-anchor="middle" x="163.01" y="-7.2" font-family="Cambria" font-size="8.00">-</text> </g> <!-- nx1&#45;&gt;nMinus --> <g id="edge5" class="edge">
<title>
nx1-&gt;nMinus
</title>
<path fill="none" stroke="red" d="M17.04,-10.54C44.85,-10.36 128.79,-9.82 154.47,-9.65"></path> <polygon fill="red" stroke="red" points="16.72,-9.67 14.23,-10.56 16.73,-11.42 16.72,-9.67"></polygon> <text text-anchor="middle" x="81.27" y="-2.9" font-family="Cambria" font-size="8.00" fill="red">-1</text> </g> <!-- nPlus&#45;&gt;nTimes --> <g id="edge4" class="edge">
<title>
nPlus-&gt;nTimes
</title>
<path fill="none" stroke="red" d="M69.49,-27.6C79.19,-27.6 93.49,-27.6 102.14,-27.6"></path> <polygon fill="red" stroke="red" points="69.14,-26.73 66.64,-27.6 69.14,-28.48 69.14,-26.73"></polygon> <text text-anchor="start" x="76.56" y="-21.4" font-family="Cambria" font-size="8.00" fill="red">v</text> <text text-anchor="start" x="80.56" y="-21.4" font-family="Cambria" baseline-shift="sub" font-size="8.00" fill="red">0</text> </g> <!-- nTimes&#45;&gt;nMinus --> <g id="edge6" class="edge">
<title>
nTimes-&gt;nMinus
</title>
<path fill="none" stroke="red" d="M121,-24.24C130.89,-20.71 146.21,-15.24 155.06,-12.08"></path> <polygon fill="red" stroke="red" points="120.68,-23.43 118.62,-25.1 121.26,-25.08 120.68,-23.43"></polygon> <text text-anchor="middle" x="134.68" y="-11.44" font-family="Cambria" font-size="8.00" fill="red">1</text> </g> <!-- ny --> <g id="node6" class="node">
<title>
ny
</title>
<text text-anchor="middle" x="214.21" y="-7.2" font-family="Cambria" font-size="8.00">y</text> </g> <!-- nMinus&#45;&gt;ny --> <g id="edge7" class="edge">
<title>
nMinus-&gt;ny
</title>
<path fill="none" stroke="red" d="M173.93,-9.6C183.88,-9.6 198.88,-9.6 207.17,-9.6"></path> <polygon fill="red" stroke="red" points="173.77,-8.73 171.27,-9.6 173.77,-10.48 173.77,-8.73"></polygon> <text text-anchor="middle" x="187.47" y="-2.4" font-family="Cambria" font-size="8.00" fill="red">1</text> </g> </g>
</svg>
</p>
<p></p><figcaption class="figure-caption">Abbildung&nbsp;5.2: Werte der Hilfsvariablen <code>vbar</code>.</figcaption><p></p>
</figure>
</div>
</div>
</div>
</div>
<hr>
<div id="exr-EigeneAADBeispiele1" class="theorem exercise">
<p><span class="theorem-title"><strong>Übungsaufgabe 5.1 (Eigene Beispiele finden) </strong></span><br></p>
<p>Schreibe eine eigene Funktion <span class="math inline">\(f : \mathbb{R}^n \rightarrow \mathbb{R}\)</span> für <span class="math inline">\(n\in\lbrace 2, 3 \rbrace\)</span> hin und erstelle den Computational Graph und ein Programm. Leite das Programm nach der oben beschriebenen AAD Methode ab und überzeuge dich an verschiedenen Stellen davon, dass der Gradient korrekt ist.</p>
</div>
<div class="callout-tip callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Lösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Beispiele findet man in der Literatur, z.B. bei <span class="citation" data-cites="sidsite2021">Radcliffe (<a href="references.html#ref-sidsite2021" role="doc-biblioref">2021</a>)</span>, <span class="citation" data-cites="Slater2022">Slater (<a href="references.html#ref-Slater2022" role="doc-biblioref">2022</a>)</span>, <span class="citation" data-cites="Baydin18">Baydin u.&nbsp;a. (<a href="references.html#ref-Baydin18" role="doc-biblioref">2018</a>)</span> (S. 13), <span class="citation" data-cites="Griewank2008EDP">Griewank und Walther (<a href="references.html#ref-Griewank2008EDP" role="doc-biblioref">2008</a>)</span> (S. 9, S. 42) oder <span class="citation" data-cites="Henrard2017ADi">Henrard (<a href="references.html#ref-Henrard2017ADi" role="doc-biblioref">2017</a>)</span> (S. 24).</p>
</div>
</div>
</div>
</section>
<section id="implementation-der-aad-mit-operator-overloading" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="implementation-der-aad-mit-operator-overloading"><span class="header-section-number">5.2</span> Implementation der AAD mit Operator Overloading</h2>
<p>Nun wollen wir ähnlich wie im <a href="ADOneDimManually.html#sec-SadImplementationOperatorOverloading"><span>Kapitel&nbsp;3.2</span></a> eine Klasse <code>FloatAad</code> entwerfen, welche die Berechnung aller Hilfsvariablen <code>vbar</code> automatisch ausführt. Wie auch zuvor hat jedes <code>FloatAad</code>-Objekt ein Attribut <code>value</code> vom Typ <code>Int</code> oder <code>Float</code>. Allerdings reicht es nicht mehr aus, ein <code>Float</code>-Attribut <code>derivative</code> zu definieren, um den Wert der Ableitung zu speichern weil auch die Struktur des Computational Graph gespeichert werden muss. Als Attribut <code>derivatives</code> wählen wir ein <code>tuple</code>, dessen erster Eintrag ein <code>FloatAad</code>-Objekt ist, nämlich die Variable, nach der die partielle Ableitung berechnet wird. Der zweite Eintrag ist der Wert dieser partiellen Ableitung. Da das erste Element des Tupels selber auch ein Attribut <code>derivatives</code> hat, entsteht so eine rekursive Darstellung des Computational Graph.</p>
<p>Die folgende Implementation lehnt sich stark an <span class="citation" data-cites="sidsite2021">Radcliffe (<a href="references.html#ref-sidsite2021" role="doc-biblioref">2021</a>)</span> an. Die Variablennamen wurden angepasst, so dass sie konsistent mit den Bezeichnungen aus <a href="ADOneDimManually.html"><span>Kapitel&nbsp;3</span></a> sind. Ausserdem werden wir unsere Klasse noch mit einiger zusätzlicher Funktionalität ausstatten, etwa mit Typunterscheidungen, so dass wir z.B. auch wieder <code>Int</code>-Zahlen zu <code>FloatAad</code>-Objekten addieren können.</p>
<section id="die-klasse-floataad" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="die-klasse-floataad"><span class="header-section-number">5.2.1</span> Die Klasse <code>FloatAad</code></h3>
<p>Wir beginnen unsere Klasse mit einer neuen Datei, welche wir <code>floataad.py</code> nennen. Als erstes definieren wir einen Konstruktor, der uns das Umwandeln von <code>Int</code>- oder <code>Float</code>-Objekten in <code>FloatAad</code>-Objekte erlaubt. Ausserdem definieren wir auch gleich eine Funktion <code>float2FloatAad</code>, mit der wir eine Liste von solchen <code>Int</code> oder <code>Float</code> in eine Liste von <code>FloatAad</code> umwandeln können und eine Funktion <code>getValues</code>, welche aus einer Liste von <code>FloatAad</code>-Objekten die Funktionswerte ausliest, siehe dazu <a href="HigherDimFunctions.html#sec-FunktionenMehrereInputs"><span>Kapitel&nbsp;4.2</span></a>.</p>
<div class="cell" data-execution_count="3">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FloatAad:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, derivatives <span class="op">=</span> ()):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.derivatives <span class="op">=</span> derivatives</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>float2FloatAad <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: FloatAad(x))</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>getValues <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x : x.value)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> FloatAad(<span class="dv">2</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(x.value)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(x.derivatives)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> float2FloatAad(x)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">type</span>(v))</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">type</span>(v[<span class="dv">0</span>]))</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">type</span>(v[<span class="dv">0</span>].value))</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">type</span>(v[<span class="dv">0</span>].derivatives))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>2
()

&lt;class 'numpy.ndarray'&gt;
&lt;class '__main__.FloatAad'&gt;
&lt;class 'int'&gt;
&lt;class 'tuple'&gt;</code></pre>
</div>
</div>
</section>
<section id="vorzeichen" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="vorzeichen"><span class="header-section-number">5.2.2</span> Vorzeichen</h3>
<p>Wir gehen bei der Implementation der unären und binären Operatoren etwas anders vor als im <a href="ADOneDimManually.html#sec-SadImplementationOperatorOverloading"><span>Kapitel&nbsp;3.2</span></a> . Wir definieren zunächst Funktionen für die Operationen und benutzen diese, um die Operatoren zu überladen. Für das negative Vorzeichen sieht das so aus:</p>
<div class="cell" data-execution_count="4">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FloatAad:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, derivatives <span class="op">=</span> ()):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.derivatives <span class="op">=</span> derivatives</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__pos__</span>(<span class="va">self</span>):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__neg__</span>(<span class="va">self</span>):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> neg(<span class="va">self</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>float2FloatAad <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: FloatAad(x))</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>getValues <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x : x.value)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neg(a):</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">*</span> a.value</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        (a, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> FloatAad(<span class="dv">2</span>)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="op">-</span>x</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(v.value)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(v.derivatives)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>-2
((&lt;__main__.FloatAad object at 0x000001F475349DE0&gt;, -1),)</code></pre>
</div>
</div>
<p>Der Wert von <code>v.derivatives</code> ist ein Tupel, dessen erster Eintrag eine Referenz auf das <code>FloatAad</code>-Objekt <code>x</code> ist und der Wert des zweiten Eintrags ist <code>-1</code> weil <span class="math inline">\(\partial v / \partial x = -1\)</span> ist.</p>
</section>
<section id="die-operatoren-und--" class="level3" data-number="5.2.3">
<h3 data-number="5.2.3" class="anchored" data-anchor-id="die-operatoren-und--"><span class="header-section-number">5.2.3</span> Die Operatoren <code>+</code> und <code>-</code></h3>
<p>Wenn wir zwei <code>FloatAad</code>-Objekte <code>a</code> und <code>b</code> addieren, dann müssen wir zwei Tupel als Ableitung zurückgeben, nämlich für <span class="math display">\[
\frac{\partial}{\partial a}(a+b)=1 \qquad\textrm{und für}\qquad \frac{\partial}{\partial b}(a+b)=1
\]</span></p>
<p>Die entsprechende Funktion sieht so aus:</p>
<div class="cell" data-execution_count="5">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add(a, b):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> a.value <span class="op">+</span> b.value</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        (a, <span class="dv">1</span>),  <span class="co"># a+b nach a abgeleitet gibt 1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        (b, <span class="dv">1</span>)   <span class="co"># a+b nach b abgeleitet gibt 1</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Für das Überladen des <code>+</code>-Operators geben wir dann einfach <code>return add(self, other)</code> zurück. Wir wollen bei dieser Gelegenheit aber gleich noch die Typabfrage implementieren, so dass wir nicht nur zwei <code>FloatAad</code>-Objekte addieren können, sondern auch Ausdrücke wie <code>x + 1</code> schreiben können. In diesem Fall brauchen wir für die <code>newDerivative</code> nur ein Tupel, welches wir direkt in der Funktion <code>__add__</code> bestimmen. Der <code>__radd__</code>-Operator, mit dem wir einen Ausdruck wie <code>1 + x</code> schreiben können, wird analog definiert.</p>
<div class="cell" data-execution_count="6">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>, other):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> <span class="va">self</span>.value <span class="op">+</span> other</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, <span class="dv">1</span>),</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> add(<span class="va">self</span>, other)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__radd__</span>(<span class="va">self</span>, other):</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> other <span class="op">+</span> <span class="va">self</span>.value</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, <span class="dv">1</span>),</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> add(other, <span class="va">self</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="exr-AadMinusOp" class="theorem exercise">
<p><span class="theorem-title"><strong>Übungsaufgabe 5.2 (Den Operator <code>-</code> implementieren) </strong></span><br></p>
<p>Implementiere die Funktionen <code>__sub__</code> und <code>__rsub__</code>. Du kannst dafür die Funktionen <code>neg(a)</code> und <code>add(a,b)</code> verwenden.</p>
</div>
<div class="callout-tip callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Lösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="cell" data-execution_count="7">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__sub__</span>(<span class="va">self</span>, other):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> <span class="va">self</span>.value <span class="op">-</span> other</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, <span class="dv">1</span>),</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> add(<span class="va">self</span>, neg(other))</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__rsub__</span>(<span class="va">self</span>, other):</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> other <span class="op">-</span> <span class="va">self</span>.value</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> add(other, neg(<span class="va">self</span>)) </span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
</div>
</section>
<section id="gradienten-berechnen" class="level3" data-number="5.2.4">
<h3 data-number="5.2.4" class="anchored" data-anchor-id="gradienten-berechnen"><span class="header-section-number">5.2.4</span> Gradienten berechnen</h3>
<p>Hier ist die bisher implementierte Klasse zusammen mit einem kleinen Testprogramm, welches die Funktion <span class="math inline">\(f(x_0, x_1) = 2x_0 - x_1 + 5\)</span> berechnet.</p>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FloatAad:</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, derivatives <span class="op">=</span> ()):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.derivatives <span class="op">=</span> derivatives</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__pos__</span>(<span class="va">self</span>):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__neg__</span>(<span class="va">self</span>):</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> neg(<span class="va">self</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>, other):</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            newValue <span class="op">=</span> <span class="va">self</span>.value <span class="op">+</span> other</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>            newDerivative <span class="op">=</span> (</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                (<span class="va">self</span>, <span class="dv">1</span>),</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> add(<span class="va">self</span>, other)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__radd__</span>(<span class="va">self</span>, other):</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>            newValue <span class="op">=</span> other <span class="op">+</span> <span class="va">self</span>.value</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>            newDerivative <span class="op">=</span> (</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>                (<span class="va">self</span>, <span class="dv">1</span>),</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> add(other, <span class="va">self</span>)</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__sub__</span>(<span class="va">self</span>, other):</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>            newValue <span class="op">=</span> <span class="va">self</span>.value <span class="op">-</span> other</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>            newDerivative <span class="op">=</span> (</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>                (<span class="va">self</span>, <span class="dv">1</span>),</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> add(<span class="va">self</span>, neg(other))</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__rsub__</span>(<span class="va">self</span>, other):</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>            newValue <span class="op">=</span> other <span class="op">-</span> <span class="va">self</span>.value</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>            newDerivative <span class="op">=</span> (</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>                (<span class="va">self</span>, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> add(other, neg(<span class="va">self</span>)) </span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>float2FloatAad <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: FloatAad(x))</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>getValues <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x : x.value)</span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neg(a):</span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">*</span> a.value</span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a>        (a, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add(a, b):</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> a.value <span class="op">+</span> b.value</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a>        (a, <span class="dv">1</span>),  <span class="co"># a+b nach a abgeleitet gibt 1</span></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a>        (b, <span class="dv">1</span>)   <span class="co"># a+b nach b abgeleitet gibt 1</span></span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a>    x0 <span class="op">=</span> FloatAad(<span class="dv">2</span>)</span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a>    x1 <span class="op">=</span> FloatAad(<span class="dv">3</span>)</span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> x0 <span class="op">+</span> x0 <span class="op">-</span> x1 <span class="op">+</span> <span class="dv">5</span></span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(y.value)</span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(y.derivatives)</span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(y.derivatives[<span class="dv">0</span>][<span class="dv">0</span>].derivatives)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>6
((&lt;__main__.FloatAad object at 0x000001F475332DD0&gt;, 1),)
((&lt;__main__.FloatAad object at 0x000001F475332CB0&gt;, 1), (&lt;__main__.FloatAad object at 0x000001F475332D40&gt;, 1))</code></pre>
</div>
</div>
<p>Wir sehen, dass der Funktionswert <span class="math inline">\(f(2,3) = 6\)</span> korrekt ist. Als Ableitung sehen wir jedoch nur ein Tupel bestehend aus einer Referenz auf ein <code>FloatAad</code>-Objekt und einem Zwischenschritt bei der Berechnung der Ableitung. Auch die Ableitung des referenzierten <code>FloatAad</code>-Objekts enthält nur ein weiteres solches Tupel. Mit anderen Worten, wir sehen noch nirgends den Wert der partiellen Ableitungen <span class="math inline">\(\partial f / \partial x_0 = 2\)</span> und <span class="math inline">\(\partial f / \partial x_1 = -1\)</span>. Wir schreiben dafür nun eine Funktion <code>getDerivatives(y)</code>, welche aus dem <code>FloatAad</code>-Objekt <code>y</code> rekursiv die partiellen Ableitungen berechnet. Dies geschieht nach der Regel, dass die Zwischenwerte der Ableitungen entlang eines Weges im Computational Graph multipliziert werden und Werte von verschiedenen Wegen, die zur gleichen Variablen <span class="math inline">\(x_i\)</span> führen, addiert werden. Für diese rekursive Berechnung definieren wir eine lokale Funktion <code>computeDerivative</code>. Der Rückgabewert soll dann ein Dictionary sein (<code>defaultdict</code> aus dem Modul <code>collections</code>, welches zu Beginn importiert werden muss), dessen Schlüsselwerte die Variablen <code>x0, x1</code> etc. sind und die zugehörigen Werte sind die partiellen Ableitungen <span class="math inline">\(\partial f / \partial x_i\)</span>.</p>
<div class="cell" data-execution_count="9">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> getDerivatives(y):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    dy <span class="op">=</span> defaultdict(<span class="kw">lambda</span>: <span class="dv">0</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> computeDerivatives(y, pathValue):</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node, localDerivative <span class="kw">in</span> y.derivatives:</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Multipliziere entlang eines Weges im Graph</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            valueOfPathToNode <span class="op">=</span> pathValue <span class="op">*</span> localDerivative</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Addiere entlang unterschiedlicher Wege</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            dy[node] <span class="op">=</span> dy[node] <span class="op">+</span> valueOfPathToNode</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Rekursion zum Durchlaufen des ganzen Graphen</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>            computeDerivatives(node, valueOfPathToNode)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialisierung mit 1 (Ableitung von y nach y)</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    computeDerivatives(y, pathValue <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dy</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Die partiellen Ableitungen können nun mit <code>dy = getDerivatives(y)</code> berechnet und mit <code>dy[x0]</code>, bzw. <code>dy[x1]</code> ausgegeben werden.</p>
<p>Wenn der Input der Funktion eine Liste <code>x0</code> ist, dann möchten wir noch eine Funktion <code>getGradient(x0, y)</code> haben, welche den Gradienten von <code>y</code> in Form einer Liste zurückgibt.</p>
<div class="cell" data-execution_count="10">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> getGradient(x0, y):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    dy <span class="op">=</span> getDerivatives(y)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    grad <span class="op">=</span> []</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x0)):</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        grad.append(dy[x0[i]])</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grad</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Mit diesen Befehlen können wir nun unsere Programme testen.</p>
<div class="cell" data-execution_count="11">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> float2FloatAad(x)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> x[<span class="dv">0</span>] <span class="op">+</span> x[<span class="dv">0</span>] <span class="op">-</span> x[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">5</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    dy <span class="op">=</span> getGradient(x, y)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(y.value)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dy)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="12">
<div class="cell-output cell-output-stdout">
<pre><code>6
[2, -1]</code></pre>
</div>
</div>
</section>
<section id="die-operatoren-und" class="level3" data-number="5.2.5">
<h3 data-number="5.2.5" class="anchored" data-anchor-id="die-operatoren-und"><span class="header-section-number">5.2.5</span> Die Operatoren <code>*</code> und <code>/</code></h3>
<p>Wenn wir zwei <code>FloatAad</code>-Objekte <code>a</code> und <code>b</code> multiplizieren, dann lauten die partiellen Ableitungen <span class="math display">\[
\frac{\partial}{\partial a}(a \cdot b)=b \qquad\textrm{und}\qquad \frac{\partial}{\partial b}(a \cdot b)=a
\]</span></p>
<p>Wir erzeugen also wieder zwei Tupel für die Ableitung.</p>
<div class="cell" data-execution_count="13">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mul(a, b):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> a.value <span class="op">*</span> b.value</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        (a, b.value),  <span class="co"># a*b nach a abgeleitet gibt b</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        (b, a.value)   <span class="co"># a*b nach b abgeleitet gibt a</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Damit überladen wir nun den <code>*</code>-Operator:</p>
<div class="cell" data-execution_count="14">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__mul__</span>(<span class="va">self</span>, other):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> <span class="va">self</span>.value <span class="op">*</span> other</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, other), </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mul(<span class="va">self</span>, other)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__rmul__</span>(<span class="va">self</span>, other):</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> other <span class="op">*</span> <span class="va">self</span>.value</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, other), </span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mul(other, <span class="va">self</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="exr-AadDivOp" class="theorem exercise">
<p><span class="theorem-title"><strong>Übungsaufgabe 5.3 (Den Operator <code>/</code> implementieren) </strong></span><br></p>
<p>Ähnlich wie in <a href="#exr-AadMinusOp">Übungsaufgabe&nbsp;<span>5.2</span></a> können wir die Division mit Hilfe der Funktion <code>mul(a,b)</code> realisieren. Schreibe dafür eine Funktion <code>inv(a)</code>, welche in <span class="math inline">\(\frac{1}{a}\)</span> als <code>FloatAad</code>-Objekt berechnet. Implementiere damit die Funktionen <code>__truediv__</code> und <code>__rtruediv__</code>.</p>
</div>
<div class="callout-tip callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Lösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Die Funktion <code>inv(a)</code>:</p>
<div class="cell" data-execution_count="15">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inv(a):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> <span class="fl">1.</span> <span class="op">/</span> a.value</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        (a, <span class="op">-</span><span class="fl">1.</span> <span class="op">/</span> a.value<span class="op">**</span><span class="dv">2</span>), </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Und damit der <code>/</code>-Operator</p>
<div class="cell" data-execution_count="16">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__truediv__</span>(<span class="va">self</span>, other):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> <span class="va">self</span>.value <span class="op">/</span> other</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, <span class="dv">1</span> <span class="op">/</span> other),</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mul(<span class="va">self</span>, inv(other))</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__rtruediv__</span>(<span class="va">self</span>, other):</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> other <span class="op">/</span> <span class="va">self</span>.value</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, <span class="op">-</span> other <span class="op">/</span> math.<span class="bu">pow</span>(<span class="va">self</span>.value,<span class="dv">2</span>)),</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mul(other, inv(<span class="va">self</span>))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
</div>
</section>
<section id="der-operator" class="level3" data-number="5.2.6">
<h3 data-number="5.2.6" class="anchored" data-anchor-id="der-operator"><span class="header-section-number">5.2.6</span> Der Operator <code>**</code></h3>
<p>Es fehlt nun nur noch der Potenzoperator. Die partiellen Ableitungen von <span class="math inline">\(a^b\)</span> lauten <span class="math display">\[
\frac{\partial}{\partial a}(a^b)=b\cdot a^{b-1} \qquad\textrm{und}\qquad \frac{\partial}{\partial b}(a^b)=a^b \cdot \ln(a)
\]</span></p>
<p>Wieder definieren wir uns zuerst eine Funktion</p>
<div class="cell" data-execution_count="17">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="bu">pow</span>(a, b):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> math.<span class="bu">pow</span>(a.value,b.value)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        (a, b.value <span class="op">*</span> math.<span class="bu">pow</span>(a.value, b.value<span class="op">-</span><span class="dv">1</span>)), <span class="co"># a^b nach a abgeleitet gibt b*a^(b-1)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        (b, math.<span class="bu">pow</span>(a.value, b.value) <span class="op">*</span> math.log(a.value))  <span class="co"># a^b nach b abgeleitet gibt a^b * ln(a)</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>und benutzen diese zur Überladung des <code>**</code>-Operators:</p>
<div class="cell" data-execution_count="18">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__pow__</span>(<span class="va">self</span>, other):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> math.<span class="bu">pow</span>(<span class="va">self</span>.value, other)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, other <span class="op">*</span> math.<span class="bu">pow</span>(<span class="va">self</span>.value, other <span class="op">-</span> <span class="dv">1</span>)),</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        ) </span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)           </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">pow</span>(<span class="va">self</span>, other)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__rpow__</span>(<span class="va">self</span>, other):</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(other) <span class="kw">in</span> [<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        newValue <span class="op">=</span> math.<span class="bu">pow</span>(other, <span class="va">self</span>.value)</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>        newDerivative <span class="op">=</span> (</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>, math.<span class="bu">pow</span>(other, <span class="va">self</span>.value) <span class="op">*</span> math.log(other)),</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">pow</span>(other, <span class="va">self</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Die fertige Klasse <code>FloatAad</code> von <a href="floataad.py">hier</a> kopiert werden.</p>
</section>
</section>
<section id="die-klasse-floataad-im-einsatz" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="die-klasse-floataad-im-einsatz"><span class="header-section-number">5.3</span> Die Klasse <code>FloatAad</code> im Einsatz</h2>
<p></p>
<p>Wir sind nun in der Lage, Gradienten von Funktionen zu berechnen, solange darin noch keine Ausdrücke wie <span class="math inline">\(\sin(x)\)</span> oder <span class="math inline">\(\ln(x)\)</span> etc. vorkommen.</p>
<div id="exm-gradientsWithAAD" class="theorem example">
<p><span class="theorem-title"><strong>Beispiel 5.2 (Gradient mit <code>FloatAad</code>) </strong></span><br></p>
<p>Betrachte die Funktion <span class="math display">\[
f(x_0, x_1, x_2) = x_0 \cdot x_1^2 + \frac{2 ^{x_1}}{x_2} - \frac{2}{x_2^2}
\]</span> Der Gradient lautet <span class="math display">\[
\nabla f = \begin{pmatrix}
    x_1^2  , \;
    2x_0x_1 + \frac{2^{x_1}\cdot\ln(2)}{x_2} , \;
    -\frac{2^{x_1}}{x_2^2}+\frac{4}{x_2^3}
    \end{pmatrix}
\]</span></p>
<p>Werten wir die Funktion an der Stelle <span class="math inline">\((x_0, x_1, x_2) = (3, 2, -1)\)</span> aus, dann erhalten wir <span class="math inline">\(f(3, 2, -1) = 6\)</span> und</p>
<p><span class="math display">\[\begin{align*}
\nabla f|_{(3, 2 -1)} &amp;= \begin{pmatrix}
    4  , \;
    12-4\cdot \ln(2) ,\;
     -8
    \end{pmatrix} \\
    &amp;\approx \begin{pmatrix}
    4  , \;
    9.23 , \;
     -8
    \end{pmatrix}
\end{align*}\]</span></p>
<p>Testen wir dies mit unserer Klasse:</p>
<div class="cell" data-execution_count="19">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> floataad <span class="im">import</span> float2FloatAad, getGradient</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    v1 <span class="op">=</span> x[<span class="dv">0</span>] <span class="op">*</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    v2 <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>x[<span class="dv">1</span>] <span class="op">/</span> x[<span class="dv">2</span>]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    v3 <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> x[<span class="dv">2</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> v1 <span class="op">+</span> v2 <span class="op">-</span> v3</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> [<span class="dv">3</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> float2FloatAad(x0)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> f(x0)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>y0 <span class="op">=</span> y.value</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> getGradient(x0, y)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Funktionswert: "</span> <span class="op">+</span> <span class="bu">str</span>(y0))</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Gradient: "</span> <span class="op">+</span> <span class="bu">str</span>(dy))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Funktionswert: 6.0
Gradient: [4.0, 9.227411277760218, -8.0]</code></pre>
</div>
</div>
</div>
<hr>
<p>Wir können mit der Klasse <code>FloatAad</code> auch die Jacobi Matrix einer Funktion <span class="math inline">\(f : \mathbb{R}^n \rightarrow \mathbb{R}^m\)</span> bestimmen. Ähnlich wie in <a href="HigherDimFunctions.html#sec-FuncRnToRm"><span>Kapitel&nbsp;4.3</span></a> benötigen wir dazu jedoch mehrere Durchgänge. Diesmal muss jede <em>Zeile</em> der Matrix <span class="math inline">\(Jf\)</span> einzeln berechnet werden. Dafür müssen wir die Methode <code>getGradient</code> <span class="math inline">\(m\)</span> Mal aufrufen, nämlich einmal für jedes <code>y[i]</code>. Um dies zu automatisieren definieren wir uns wieder zwei Funktionen <code>getValues</code> und <code>getJacobian</code> (welche wir natürlich auch in die Klasse <code>FloatAad</code> schreiben könnten). Während <code>FloatSad</code> günstig war, solange <span class="math inline">\(n&lt;m\)</span> war, so ist <code>FloatAad</code> günstig, wenn <span class="math inline">\(n&gt;m\)</span> ist.</p>
<div id="exm-JacobianWithAad" class="theorem example">
<p><span class="theorem-title"><strong>Beispiel 5.3 (Jacobi Matrix mit <code>FloatAad</code>) </strong></span><br></p>
<p>Wir betrachten die Funktion <span class="math inline">\(f : \mathbb{R}^3 \rightarrow \mathbb{R}^2\)</span> mit <span class="math display">\[
f(x_0, x_1, x_2) =
    \begin{pmatrix}
        y_0 \\ y_1
    \end{pmatrix}
    =
    \begin{pmatrix}
        x_0 + x_1^2 + \frac{1}{x_2} \\
        x_0 \cdot x_1 \cdot x_2
    \end{pmatrix}
\]</span></p>
<p>Die Jacobi Matrix lautet <span class="math display">\[\begin{align*}
Jf &amp;=
    \begin{pmatrix}
        \frac{\partial y_0}{\partial x_0} &amp; \frac{\partial y_0}{\partial x_1} &amp; \frac{\partial y_0}{\partial x_2} \\
        \frac{\partial y_1}{\partial x_0} &amp; \frac{\partial y_1}{\partial x_1} &amp; \frac{\partial y_1}{\partial x_2}
    \end{pmatrix} \\
    &amp;=
    \begin{pmatrix}
        1 &amp; 2x_1 &amp; -\frac{1}{x_2 ^2} \\
        x_1 x_2 &amp; x_0 x_2 &amp; x_0 x_1
    \end{pmatrix}
\end{align*}\]</span></p>
<p>Ausgewertet an der Stelle <span class="math inline">\((x_0, x_1, x_2) = (-2, -4, 0.5)\)</span> erhalten wir <span class="math inline">\(f(-2, -4, 0.5) = (16, 4)^\intercal\)</span> und <span class="math display">\[
Jf|_{(-2,-4,0.5)} =
\begin{pmatrix}
    1 &amp; -8 &amp; -4 \\
    -2 &amp; -1 &amp; 8
\end{pmatrix}
\]</span></p>
<p>Als Programm mit den oben beschriebenen Funktionen erhalten wir</p>
<div class="cell" data-execution_count="20">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> floataad <span class="im">import</span> float2FloatAad, getGradient</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    y0 <span class="op">=</span> x[<span class="dv">0</span>] <span class="op">+</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span><span class="op">/</span>x[<span class="dv">2</span>]</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    y1 <span class="op">=</span> x[<span class="dv">0</span>] <span class="op">*</span> x[<span class="dv">1</span>] <span class="op">*</span> x[<span class="dv">2</span>]</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [y0, y1]</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> [<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">4</span>,<span class="fl">0.5</span>]</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> float2FloatAad(x0)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>getValues <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> y : y.value)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>getJacobian <span class="op">=</span> <span class="kw">lambda</span> x,y : np.array([getGradient(x, y[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(y))])</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> f(x0)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>val <span class="op">=</span> getValues(y)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>Jacobian <span class="op">=</span> getJacobian(x0, y)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Funktionswert: "</span> <span class="op">+</span><span class="bu">str</span>(val))</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Jf ="</span>)</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Jacobian)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Funktionswert: [16.  4.]
Jf =
[[ 1. -8. -4.]
 [-2. -1.  8.]]</code></pre>
</div>
</div>
</div>
<hr>
<section id="gradient-descent-zum-auffinden-lokaler-minima" class="level3" data-number="5.3.1">
<h3 data-number="5.3.1" class="anchored" data-anchor-id="gradient-descent-zum-auffinden-lokaler-minima"><span class="header-section-number">5.3.1</span> Gradient Descent zum Auffinden lokaler Minima</h3>
<p>Eine Funktion <span class="math inline">\(f : \mathbb{R}^2 \rightarrow \mathbb{R}\)</span> kann man sich als eine i.A. gekrümmte Fläche im <span class="math inline">\(\mathbb{R}^3\)</span> vorstellen. Der Gradient <span class="math inline">\(\nabla f|_{(x_0, x_1)}\)</span> ist ein Vektor in <span class="math inline">\(\mathbb{R}^2\)</span>, der gerade in die Richtung des steilsten Anstiegs der Fläche beim Punkt <span class="math inline">\((x_0, x_1)\)</span> zeigt. Entsprechend zeigt <span class="math inline">\(-\nabla f\)</span> in die Richtung des steilsten Abstiegs, siehe <span class="citation" data-cites="Arens2022">Arens u.&nbsp;a. (<a href="references.html#ref-Arens2022" role="doc-biblioref">2022</a>)</span>, S. 871. Damit lässt sich die Gradient Descent Methode zur Bestimmung eines lokalen Minimums, die wir im <a href="intro.html#sec-gradientDescent"><span>Kapitel&nbsp;1.3.2</span></a> kennen gelernt haben, auch zum Auffinden eines lokalen Minimums einer Fläche verwenden. Sie lässt sich sogar auf Funktionen <span class="math inline">\(f : \mathbb{R}^n \rightarrow \mathbb{R}\)</span> anwenden, siehe <span class="citation" data-cites="Arens2022">Arens u.&nbsp;a. (<a href="references.html#ref-Arens2022" role="doc-biblioref">2022</a>)</span>, S. 1324.</p>
<p>Im Fall einer 2-dimensionalen Fläche starten wir an einem Punkt <span class="math inline">\((x_{0,0}, x_{1,0})\)</span>, welchen wir durch seinen Ortsvektor <span class="math inline">\(\vec{x}_0\)</span> beschreiben. Dann berechnen wir rekursiv eine Folge von (Ortsvektoren zu) Punkten <span class="math inline">\(\vec{x}_n\)</span>, welche im Idealfall zu einem lokalen Minimum der Funktion konvergieren, gemäss der Vorschrift <span class="math display">\[
\vec{x}_{n+1} = \vec{x}_n - \lambda\cdot(\nabla f(\vec{x}_n))^\intercal
\]</span></p>
<p><span class="math inline">\(\lambda\in\mathbb{R}^+\)</span> beeinflusst wie im <a href="intro.html#sec-gradientDescent"><span>Kapitel&nbsp;1.3.2</span></a> die Schrittweite. Ist <span class="math inline">\(\lambda\)</span> zu klein, dann konvergiert die Iteration nur sehr langsam, wird <span class="math inline">\(\lambda\)</span> hingegen zu gross gewählt, dann kann es passieren, dass sich die Iteration von einem lokalen Minimum wieder weg bewegt.</p>
<div id="exm-gradientDescentWithAAD" class="theorem example">
<p><span class="theorem-title"><strong>Beispiel 5.4 (Gradient Descent auf einer Fläche) </strong></span><br></p>
<p>Betrachte die Funktion <span class="math inline">\(f(x_0, x_1) = x_0^4 + x_1^4 + x_0 x_1^3 - x_0^2 x_1 - x_1^2\)</span>.</p>
<div>
<p>Hier wird diese Funktion einmal als 2-dimensionale Fläche und einmal als mit Hilfe von Konturlinien dargestellt. Im linken Feld kann man den Startpunkt und <span class="math inline">\(\lambda\)</span> wählen und die ersten 30 Iterationen darstellen.</p>
<div class="fig-GradientDescent2DGeoGebra">
<iframe scrolling="no" title="Gradient descent 2d" src="https://www.geogebra.org/material/iframe/id/c2zjuxef/width/700/height/600/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/true/rc/false/ld/false/sdz/true/ctl/false" width="700px" height="600px" style="border:0px;">
</iframe>
</div>
<p>Man erkennt, dass die Funktion drei lokale Minima hat.</p>
</div>
<p>Nun wollen wir ein lokales Minimum mit Hilfe der Gradient Descent Methode finden. Damit wir <span class="math inline">\(\lambda \cdot (\nabla f)\)</span> als <code>lam * df</code> berechnen können, wandeln wir die Liste, die wir mit <code>getGradient</code> erhalten, in ein <code>numpy</code>-array um. Die oben beschriebene Iteration wird so lange ausgeführt, bis <span class="math inline">\(|\vec{x}_{n+1}-\vec{x}_n|\le 10^{-6}\)</span> ist.</p>
<div class="cell" data-execution_count="21">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> floataad <span class="im">import</span> float2FloatAad, getGradient</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">4</span> <span class="op">+</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">4</span> <span class="op">+</span> x[<span class="dv">0</span>] <span class="op">*</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">3</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> y <span class="op">-</span> x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> x[<span class="dv">1</span>] <span class="op">-</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>getValues <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> y : y.value)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Startwert und Lambda für Gradient Descent</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> [<span class="fl">0.5</span>, <span class="dv">0</span>]</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>lam <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">1e-6</span> <span class="co"># Toleranz für Abbruchbedingung</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> float2FloatAad(x0)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>y0 <span class="op">=</span> f(x0)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> np.array(getGradient(x0, y0))</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Erster Schritt</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> x0 <span class="op">-</span> lam <span class="op">*</span> dy</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Iteration bis die Distanz zwischen zwei</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="co"># aufeinanderfolgenden Punkten kleiner ist als tol.</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> np.linalg.norm(getValues(x0) <span class="op">-</span> getValues(x1)) <span class="op">&gt;</span> tol:</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    x0 <span class="op">=</span> x1</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>    y0 <span class="op">=</span> f(x0)</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    dy <span class="op">=</span> np.array(getGradient(x0, y0))</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    x1 <span class="op">=</span> x0 <span class="op">-</span> lam <span class="op">*</span> dy</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Lokales Minimum gefunden in der Nähe von"</span>)</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(getValues(x1))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Lokales Minimum gefunden in der Nähe von
[0.40427048 0.6160611 ]</code></pre>
</div>
</div>
</div>
<hr>
<p>Die folgenden drei Abschnitte beschreiben verschiedene Anwendungen des Gradient Descent Verfahrens, die wir mit Hilfe von <code>FloatAad</code> programmieren können.</p>
</section>
<section id="lineare-regression" class="level3" data-number="5.3.2">
<h3 data-number="5.3.2" class="anchored" data-anchor-id="lineare-regression"><span class="header-section-number">5.3.2</span> Lineare Regression</h3>
<p>Beim klassischen Ausgleichsproblem sind <span class="math inline">\(n\)</span> Datenpunkte <span class="math inline">\((x_i , y_i)\)</span> (Messwerte) gegeben, zwischen denen ein linearer Zusammenhang vermutet wird, d.h. <span class="math inline">\(y_i \approx g(x_i) = a\cdot x_i + b\)</span>. Auf Grund von Messfehlern und anderen Einflüssen können wir jedoch nicht erwarten, dass der Zusammenhang exakt einer linearen Funktion entspricht, d.h. der Fehler <span class="math inline">\(y_i - g(x_i)\)</span> ist im Allgemeinen nicht Null. Das Ziel ist nun, die Parameter <span class="math inline">\(a\)</span> und <span class="math inline">\(b\)</span> so zu bestimmen, dass die Summe der Quadrate dieser Fehler möglichst klein wird. Mit anderen Worten: wir suchen das Minimum der Funktion <span class="math inline">\(\Phi : \mathbb{R}^2 \rightarrow \mathbb{R}\)</span> <span class="math display">\[
\Phi(a, b) = \sum_{i = 1}^n (y_i - (a\cdot x_i + b))^2
\]</span> Dieser Ansatz stammt von Gauss und wird auch die Methode der kleinsten Fehlerquadrate genannt. Die Funktion <span class="math inline">\(\Phi\)</span> wird insbesondere im Kontext des maschinellen Lernens auch <em>Loss Funktion</em> genannt. Da es sich bei <span class="math inline">\(\Phi(a,b)\)</span> um eine quadratische Funktion in <span class="math inline">\(a\)</span> und <span class="math inline">\(b\)</span> handelt, besitzt sie ein eindeutiges Minimum, welches auch rein analytisch gefunden werden kann, siehe z.B. <span class="citation" data-cites="Arens2022">Arens u.&nbsp;a. (<a href="references.html#ref-Arens2022" role="doc-biblioref">2022</a>)</span>, S. 1526. Wir wollen das Minimum aber mit dem Gradient Descent Verfahren bestimmen. Als Startwert verwenden wir einfach <span class="math inline">\((a, b) = (0, 0)\)</span>.</p>
<div id="exm-LinearRegressionWithGradientDescent" class="theorem example">
<p><span class="theorem-title"><strong>Beispiel 5.5 (Lineare Regression mit Gradient Descent und <code>AAD</code>) </strong></span><br></p>
<p>In diesem Beispiel gehen wir davon aus, dass der korrekte, aber unbekannte, lineare Zusammenhang durch <span class="math inline">\(y = f(x) = 2x+3\)</span> gegeben ist. Wir erzeugen zunächst eine Anzahl von <code>anz = 50</code> Datenpunkten, die zufällig um diese Gerade streuen. Danach versuchen wir, die Parameter <span class="math inline">\(a\)</span> und <span class="math inline">\(b\)</span> mittels linearer Regression aus diesen Datenpunkten zu rekonstruieren. Die Funktion <code>loss(a, b)</code> berechnet die Funktion <span class="math inline">\(\Phi(a,b)\)</span>, deren Ableitung automatisch mittels <code>FloatAad</code> berechnet wird. Der so berechnete Gradient von <span class="math inline">\(\Phi\)</span> wird für das Gradient Descent Verfahren verwendet. Da die Funktion nur zwei unabhängige Variablen hat, verwenden wir direkt den Konstruktor <code>FloatAad</code> und die Methode <code>getDerivatives</code> anstelle der vektorisierten Methoden <code>float2FloatAad</code> und <code>getGradient</code>. Schliesslich werden die Datenpunkte zusammen mit der korrekten Funktion <span class="math inline">\(f\)</span> und der Ausgleichsgeraden <span class="math inline">\(g\)</span> grafisch dargestellt.</p>
<div class="cell" data-execution_count="22">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> floataad <span class="im">import</span> FloatAad, getDerivatives</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loss(a, b):</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># X und Y werden im global space gefunden</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">sum</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(X)):</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> <span class="bu">float</span>(Y[i]) <span class="op">-</span> (a <span class="op">*</span> <span class="bu">float</span>(X[i]) <span class="op">+</span> b)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sum</span> <span class="op">+=</span> d<span class="op">**</span><span class="dv">2</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(<span class="bu">sum</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameter zur Erzeugung der Datenpunkte</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>anz <span class="op">=</span> <span class="dv">50</span> <span class="co"># Anzahl Datenpunkte</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>xmin, xmax <span class="op">=</span> <span class="dv">0</span>, <span class="dv">10</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="dv">2</span>    <span class="co"># Streuung</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Erzeugende Funktion</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">2</span> <span class="op">*</span> x <span class="op">+</span> <span class="dv">3</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Daten erzeugen</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.linspace(xmin, xmax, anz)</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> f(X)</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Rauschen hinzufügen</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> Y <span class="op">+</span> s <span class="op">*</span> np.random.randn(anz)</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Gradient Descent</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>lam <span class="op">=</span> <span class="fl">0.0005</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>a0, b0 <span class="op">=</span> FloatAad(<span class="dv">0</span>), FloatAad(<span class="dv">0</span>) <span class="co"># Startwerte</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>Phi <span class="op">=</span> loss(a0, b0)</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>dPhi <span class="op">=</span> getDerivatives(Phi)</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>a1 <span class="op">=</span> a0 <span class="op">-</span> lam <span class="op">*</span> dPhi[a0]</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>b1 <span class="op">=</span> b0 <span class="op">-</span> lam <span class="op">*</span> dPhi[b0]</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (a1.value<span class="op">-</span>a0.value)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (b1.value<span class="op">-</span>b0.value)<span class="op">**</span><span class="dv">2</span> <span class="op">&gt;</span> <span class="fl">1e-9</span>:</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>    a0, b0 <span class="op">=</span> a1, b1</span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>    Phi <span class="op">=</span> loss(a0, b0)</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>    dPhi <span class="op">=</span> getDerivatives(Phi)</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">=</span> a0 <span class="op">-</span> lam <span class="op">*</span> dPhi[a0]</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>    b1 <span class="op">=</span> b0 <span class="op">-</span> lam <span class="op">*</span> dPhi[b0]</span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Regressionsgerade</span></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>a, b <span class="op">=</span> a1.value, b1.value</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x : a <span class="op">*</span> x <span class="op">+</span> b)</span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"y = g(x) = "</span> <span class="op">+</span> <span class="bu">str</span>(a) <span class="op">+</span> <span class="st">"x + "</span> <span class="op">+</span> <span class="bu">str</span>(b))</span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a><span class="co"># Daten darstellen</span></span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>plt.plot(X,Y, <span class="st">'b.'</span>, X, f(X), <span class="st">'r--'</span>, X, g(X), <span class="st">'g-.'</span>)</span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>plt.legend([<span class="st">"Datenpunkte"</span>, <span class="st">"Erzeugende Funktion"</span>, <span class="st">"Regressionsgerade"</span>])</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>y = g(x) = 1.9970709230222317x + 2.7231287432323</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-graphoflinearregression" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="aad_files/figure-html/fig-graphoflinearregression-output-2.png" width="566" height="411" class="figure-img"></p>
<p></p><figcaption class="figure-caption">Abbildung&nbsp;5.3: Ausgleichsgerade.</figcaption><p></p>
</figure>
</div>
</div>
</div>
</div>
<hr>
</section>
<section id="bilder-schärfen" class="level3" data-number="5.3.3">
<h3 data-number="5.3.3" class="anchored" data-anchor-id="bilder-schärfen"><span class="header-section-number">5.3.3</span> Bilder schärfen</h3>
<p>Die Idee zu dieser Anwendung stammt von <span class="citation" data-cites="Slater2022">Slater (<a href="references.html#ref-Slater2022" role="doc-biblioref">2022</a>)</span>. Beim Fotografieren kann es passieren, dass die Linse der Kamera nicht richtig fokussiert ist und das Bild dadurch unscharf wirkt. Es ist jedoch möglich, ein Bild bis zu einem gewissen Grad nachträglich zu schärfen.</p>
<p>Als Testbild verwenden wir das folgende Bild eines Teddybären, welches unter der Creative Commons 4.0 Lizenz auf <a href="https://www.pngall.com/toy-png/download/55843">https://www.pngall.com/toy-png/download/55843</a> [Letzter Zugriff 02.04.2023] zur Verfügung gestellt wird. Allerdings müssen wir die Auflösung von ursprünglich 180 x 180 Pixel auf 30 x 30 Pixel reduzieren, was mit jeder Bildbearbeitungssoftware gemacht werden kann. Der Grund dafür ist, dass die Anzahl Pixel darüber entscheidet, wie viele <code>FloatAad</code>-Objekte wir erzeugen müssen und während des Gradient Descent Verfahrens wird der Computational Graph bei vielen Variablen sehr gross, so dass beim Berechnen der Ableitungen die maximale Rekursionstiefe überschritten würde. Wir verwenden also das in rechts dargestellte Bild <code>Bear30.jpg</code>.</p>
<div id="fig-teddys" class="quarto-layout-panel">
<figure class="figure">
<div class="quarto-layout-row quarto-layout-valign-bottom">
<div class="quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-originalTeddy" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="Bear_original.png" class="img-fluid figure-img" data-ref-parent="fig-teddys"></p>
<p></p><figcaption class="figure-caption">(a) Original 180 x 180</figcaption><p></p>
</figure>
</div>
</div>
<div class="quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-smallTeddy" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="Bear30.jpg" class="img-fluid figure-img" data-ref-parent="fig-teddys" width="180"></p>
<p></p><figcaption class="figure-caption">(b) Testbild 30 x 30</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Abbildung&nbsp;5.4: Testbild eines Teddybärs.</figcaption><p></p>
</figure>
</div>
<p>Es stellt sich heraus, dass selbst diese kleine Auflösung noch zu viele <code>FloatAad</code>-Objekte benötigt weil jedes Pixel drei Farbkanäle hat. Daher wandeln wir das Bild nach dem Laden zuerst in ein Graustufenbild um.</p>
<div class="cell" data-execution_count="23">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.image <span class="im">import</span> imread</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> floataad <span class="im">import</span> float2FloatAad, getGradient</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> imread(<span class="st">'bear30.jpg'</span>) <span class="op">/</span> <span class="dv">255</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Bild in Graustufenbild umwandeln</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">3</span> <span class="op">*</span> (original[:,:,<span class="dv">0</span>] <span class="op">+</span> original[:,:,<span class="dv">1</span>] <span class="op">+</span> original[:,:,<span class="dv">2</span>])</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>[length, width] <span class="op">=</span> np.shape(image)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Um die Unschärfe einer schlecht fokussierten Linse zu simulieren, wenden wir einen <em>Gaussian Blur</em> an. Wie das genau funktioniert wird z.B. in diesem Video von Grant Sanderson von <a href="https://www.3blue1brown.com">3blue1brown</a> [Letzter Zugriff 02.04.2023] erklärt.</p>
<div class="quarto-video ratio ratio-16x9"><iframe src="https://www.youtube.com/embed/KuXjwB4LzSA?start=512" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>Die folgende Funktion wendet einen solchen Gaussian Blur auf ein Bild an. Die Vorlage des Codes stammt aus dem Forumsbeitrag <a href="https://stackoverflow.com/questions/29920114/how-to-gauss-filter-blur-a-floating-point-numpy-array">How to gauss-filter (blur) a floating point numpy array</a> von stackoverflow [Letzter Zugriff 02.04.2023] und wurde so abgeändert, dass die kernel-Grösse selber bestimmt werden kann.</p>
<div class="cell" data-execution_count="24">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> blur(a): </span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># kernel erzeugen</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    kernel_size <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span> [np.array([math.comb(kernel_size, k) <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(kernel_size)])]</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> np.dot(np.transpose(k1), k1)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> kernel <span class="op">/</span> np.<span class="bu">sum</span>(kernel)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Faltung (Convolution) ausführen</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    arraylist <span class="op">=</span> []</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(kernel_size):</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>        temparray <span class="op">=</span> np.copy(a)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>        temparray <span class="op">=</span> np.roll(temparray, y <span class="op">-</span> <span class="dv">1</span>, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(kernel_size):</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>            temparray_X <span class="op">=</span> np.copy(temparray)</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>            temparray_X <span class="op">=</span> np.roll(temparray_X, x <span class="op">-</span> <span class="dv">1</span>, axis<span class="op">=</span><span class="dv">1</span>)<span class="op">*</span>kernel[y,x]</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>            arraylist.append(temparray_X)</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    arraylist <span class="op">=</span> np.array(arraylist)</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    arraylist_sum <span class="op">=</span> np.<span class="bu">sum</span>(arraylist, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> arraylist_sum</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Nun wenden wir diesen Filter auf unser Testbild an.</p>
<div class="cell" data-execution_count="25">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Blur erzeugen</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>blurredimage <span class="op">=</span> blur(image)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>blurrarray <span class="op">=</span> np.reshape(blurredimage, length<span class="op">*</span>width)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Original"</span>)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>ax.set_axis_off()</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(image, cmap <span class="op">=</span> <span class="st">"gray"</span>)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Blurred"</span>)</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>ax.set_axis_off()</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurredimage, cmap <span class="op">=</span> <span class="st">"gray"</span>)</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-testbildmitblur" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="aad_files/figure-html/fig-testbildmitblur-output-1.png" width="540" height="276" class="figure-img"></p>
<p></p><figcaption class="figure-caption">Abbildung&nbsp;5.5: Testbild und Blur.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Unser Ziel ist wie gesagt, mit Hilfe des Gradient Descent Verfahrens aus dem unscharfen Bild rechts wieder so nahe wie möglich an das Original heranzukommen. Dazu beginnen wir mit einem “Startwert”, das ein Bild ist, welches aus 30 x 30 Pixeln besteht, die alle den Wert 0.5 haben, d.h. mit einem grauen Bild.</p>
<div class="cell" data-execution_count="26">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Startwert</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>guessimage <span class="op">=</span> np.full(shape <span class="op">=</span> [length, width], fill_value<span class="op">=</span><span class="fl">0.5</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Diese <span class="math inline">\(30\times30=900\)</span> Pixelwerte sind nun der Input unserer Loss Funktion und werden im Laufe der Gradient Descent Iteration so verändert, dass sie diese Funktion minimieren. Diese Loss Funktion definieren wir folgendermassen: Auf das <code>guessimage</code> wird zuerst ein Gaussian Blur angewendet. Danach betrachten wir die Differenzen <code>blur(guessimage) - blurredimage</code> in jedem Pixel. Nach dem Gauss’schen Ansatz der kleinsten Fehlerquadrate definieren wir die Loss Funktion als Summe der Quadrate aller Fehler in den einzelnen Pixeln. Dahinter steckt die Idee, dass wenn die Differenzen zwischen den unscharfen Bildern <code>blur(guessimage) - blur(original)</code> klein ist, dann sollten auch die Differenzen <code>guessimage - original</code> klein sein, d.h. <code>testimage</code> sollte in etwa dem <code>original</code> entsprechen.</p>
<p>Für die konkrete Umsetzung wandeln wir das Bild mit den <span class="math inline">\(30\times30\)</span> Pixeln in einen Vektor der Länge 900 um. Das haben wir für für das <code>blurredimage</code> bereits in der Zeile <code>blurrarray = np.reshape(blurredimage, length*width)</code> gemacht. Für das <code>guessimage</code> müssen wir nach der Umwandlung die 900 Einträge zunächst in <code>FloatAad</code>-Objekte umwandeln. All das geschieht in der folgenden Funktion.</p>
<div class="cell" data-execution_count="27">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loss(x):</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input x ist ein Bild, auf welches der Gauss Filter angewendet wird</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Danach wird das Bild als 1-dim. Array gespeichert</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    [length, width] <span class="op">=</span> np.shape(x)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    temp <span class="op">=</span> blur(x)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    temparray <span class="op">=</span> np.reshape(temp, length <span class="op">*</span> width)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Umwandeln in FloatAad</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    temparray <span class="op">=</span> float2FloatAad(temparray)</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="bu">sum</span>((temparray <span class="op">-</span> blurrarray) <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> getGradient(temparray, y)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [y.value, g]</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Nun können wir das Gradient Descent Verfahren anwenden.</p>
<div class="cell" data-execution_count="28">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Gradient Descent Parameter</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>lam <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>[lossval, grad] <span class="op">=</span> loss(guessimage)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> lossval <span class="op">&gt;</span> tol:</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    [lossval, grad] <span class="op">=</span> loss(guessimage) </span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> np.reshape(grad, [length, width])</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    guessimage <span class="op">=</span> guessimage <span class="op">-</span> lam <span class="op">*</span> diff</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Guess"</span>)</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>ax.set_axis_off()</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>plt.imshow(guessimage, cmap <span class="op">=</span> <span class="st">"gray"</span>)</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Blurred Guess"</span>)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>ax.set_axis_off()</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>blurredguess <span class="op">=</span> blur(guessimage)</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurredguess, cmap <span class="op">=</span> <span class="st">"gray"</span>)</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Original - Guess"</span>)</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>ax.set_axis_off()</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>diffOrig <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> (image <span class="op">-</span> guessimage <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>plt.imshow(diffOrig, cmap <span class="op">=</span> <span class="st">"gray"</span>)</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>)</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Blurred - Blurred Guess"</span>)</span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>ax.set_axis_off()</span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>diffBlurred <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> (blurredimage <span class="op">-</span> blurredguess <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>plt.imshow(diffBlurred, cmap <span class="op">=</span> <span class="st">"gray"</span>)</span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-imagereconstructionresult" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="aad_files/figure-html/fig-imagereconstructionresult-output-1.png" width="480" height="409" class="figure-img"></p>
<p></p><figcaption class="figure-caption">Abbildung&nbsp;5.6: Resultat des Schärfens und Differenz zum Original</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Das vollständige Programm kann auch <a href="deblurImage.py">hier</a> heruntergeladen werden.</p>
</section>
</section>
<section id="sec-modulMathAad" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="sec-modulMathAad"><span class="header-section-number">5.4</span> Das Modul <code>mathaad</code></h2>
<p>In diesem Kapitel schreiben wir ein Modul <code>mathaad</code>, welches eine Auswahl an mathematischen Funktionen beinhaltet, die auf <code>FloatAad</code>-Objekte angewendet werden können. Wir gehen dabei analog zum <a href="ADOneDimManually.html#sec-modulMathSad"><span>Kapitel&nbsp;3.4</span></a> vor, beschränken uns aber auf die Funktionen <code>sqrt</code>, <code>exp</code>, <code>log</code> und die drei trigonometrischen Funktionen. Ausserdem verwenden wir Funktionen aus <code>numpy</code> weil wir als Argumente auch Arrays von <code>FloatAad</code>-Objekte übergeben wollen. Die Funktion soll in diesem Fall elementweise angewendet werden, wofür der Decorator <code>@np.vectorize</code> sorg. Der folgende Code sollte in einer Datei <code>mathaad.py</code> gespeichert und im gleichen Ordner wie die anderen Dateien abgelegt werden.</p>
<div class="cell" data-execution_count="29">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> floataad <span class="im">import</span> FloatAad</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="at">@np.vectorize</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sqrt(x):</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> np.sqrt(x.value)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        (x, <span class="fl">1.</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> np.sqrt(x.value))),</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="at">@np.vectorize</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exp(x):</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> np.exp(x.value)</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>        (x, newValue),</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a><span class="at">@np.vectorize</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> log(x):</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> np.log(x.value)</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>        (x, <span class="fl">1.</span> <span class="op">/</span> x.value),</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a><span class="at">@np.vectorize</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sin(x):</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> np.sin(x.value)</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>        (x, np.cos(x.value)),</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a><span class="at">@np.vectorize</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cos(x):</span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>    newValue <span class="op">=</span> np.cos(x.value)</span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>    newDerivative <span class="op">=</span> (</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>        (x, <span class="op">-</span>np.sin(x.value)),</span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FloatAad(newValue, newDerivative)</span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a><span class="at">@np.vectorize</span></span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tan(x):</span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sin(x) <span class="op">/</span> cos(x)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Die Datei kann <a href="mathaad.py">hier</a> heruntergeladen werden.</p>
</section>
<section id="das-modul-mathaad-im-einsatz" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="das-modul-mathaad-im-einsatz"><span class="header-section-number">5.5</span> Das Modul <code>mathaad</code> im Einsatz</h2>
<p>Zum Schluss wollen wir uns ein einfaches neuronales Netz zur Lösung eines berühmten Klassifikationsproblems programmieren.</p>
<section id="ein-einaches-neuronales-netz-zur-klassifikation-von-lilien" class="level3" data-number="5.5.1">
<h3 data-number="5.5.1" class="anchored" data-anchor-id="ein-einaches-neuronales-netz-zur-klassifikation-von-lilien"><span class="header-section-number">5.5.1</span> Ein einaches neuronales Netz zur Klassifikation von Lilien</h3>
<p>Wir verwenden für dieses Beispiel einen der bekanntesten Datensätze, nämlich Fisher’s Datensatz zu Lilien. Er wurde bereits 1936 vom britischen Biologen und Statistier Ronald Fisher verwendet und ist heute nach ihm benannt. Auch in <span class="citation" data-cites="Hromkovic2022">Barot u.&nbsp;a. (<a href="references.html#ref-Hromkovic2022" role="doc-biblioref">2022</a>)</span> (S. 160) wird auf diesen Datensatz Bezug genommen. Die Datei <a href="iris.data">iris.data</a> kann von <span class="citation" data-cites="Fisher1936">Fisher (<a href="references.html#ref-Fisher1936" role="doc-biblioref">1936</a>)</span> heruntergeladen werden. Über diesen Datensatz liest man dort</p>
<blockquote class="blockquote">
<p>[It is] A small classic dataset from Fisher, 1936. One of the earliest datasets used for evaluation of classification methodologies. […] This is perhaps the best known database to be found in the pattern recognition literature. Fisher’s paper is a classic in the field and is referenced frequently to this day.</p>
</blockquote>
<p>Die Datei enthält 150 Datensätze (Zeilen) mit je 5 Spalten. Die 1. Spalte gibt die Länge des Kelchblattes (Sepalum) an, die 2. Spalte die Breite des Kelchblattes, die 3. Spalte enthält die Länge des Kornblattes (Petalum) und die 4. Spalte enthält die Breite des Kornblattes. Die 5. Spalte schliesslich gibt an, von welcher Lilienart die Daten stammen. Im Datensatz gibt es drei Arten von Lilien (Iris setosa, Iris versicolor und Iris virginica) und von jeder Art sind 50 Messungen enthalten.</p>
<p>Unser Ziel wird es sein, auf Grund der vier gemessenen Grössen (Länge und Breite des Kelch- bzw. Kornblattes) die Art vorher zu sagen. Als erstes wollen wir die Daten grafisch als Scatterplot darstellen (<span class="citation" data-cites="Frochte2021">Frochte (<a href="references.html#ref-Frochte2021" role="doc-biblioref">2021</a>)</span>, S. 71). Zunächst ändern wir aber die Label in der 5. Spalte noch zu <code>0</code> (Iris setosa), <code>1</code> (Iris versicolor), bzw. <code>2</code> (Iris virginica)</p>
<div class="cell" data-execution_count="30">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> floataad <span class="im">import</span> float2FloatAad, getValues, getGradient</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mathaad</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Daten einlesen</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Label in 0 (Iris-setosa), bzw. 1 (Iris-versicolor), bzw. 2 (Iris-virginica) ändern</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>fString <span class="op">=</span> <span class="bu">open</span>(<span class="st">'iris.data'</span>,<span class="st">'r'</span>)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>fFloat  <span class="op">=</span> <span class="bu">open</span>(<span class="st">'iris.csv'</span>,<span class="st">'w'</span>)</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> line <span class="kw">in</span> fString:</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    line <span class="op">=</span> line.replace(<span class="st">'Iris-setosa'</span>, <span class="st">'0'</span>)</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    line <span class="op">=</span> line.replace(<span class="st">'Iris-versicolor'</span>, <span class="st">'1'</span>)</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    line <span class="op">=</span> line.replace(<span class="st">'Iris-virginica'</span>, <span class="st">'2'</span>)</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    fFloat.write(line)</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>fString.close()</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>fFloat.close()</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>fFloat <span class="op">=</span> <span class="bu">open</span>(<span class="st">'iris.csv'</span>,<span class="st">'r'</span>)</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> np.loadtxt(fFloat, delimiter <span class="op">=</span> <span class="st">','</span>)</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>fFloat.close()</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Daten plotten</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(<span class="dv">1</span>)</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">0</span>:<span class="dv">50</span>,<span class="dv">0</span>], dataset[<span class="dv">0</span>:<span class="dv">50</span>,<span class="dv">1</span>], </span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'red'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">0</span>], dataset[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">1</span>], </span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'green'</span>, marker <span class="op">=</span> <span class="st">'^'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">100</span>:<span class="dv">150</span>,<span class="dv">0</span>], dataset[<span class="dv">100</span>:<span class="dv">150</span>,<span class="dv">1</span>], </span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'blue'</span>, marker <span class="op">=</span> <span class="st">'*'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Kelchblattlaenge (cm)'</span>)</span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Kelchblattbreite (cm)'</span>)</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">0</span>:<span class="dv">50</span>,<span class="dv">2</span>], dataset[<span class="dv">0</span>:<span class="dv">50</span>,<span class="dv">3</span>], </span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'red'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">2</span>], dataset[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">3</span>], </span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'green'</span>, marker <span class="op">=</span> <span class="st">'^'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">100</span>:<span class="dv">150</span>,<span class="dv">2</span>], dataset[<span class="dv">100</span>:<span class="dv">150</span>,<span class="dv">3</span>], </span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'blue'</span>, marker <span class="op">=</span> <span class="st">'*'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Kronblattlaenge (cm)'</span>)</span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Kronblattbreite (cm)'</span>)</span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">0</span>:<span class="dv">50</span>,<span class="dv">0</span>], dataset[<span class="dv">0</span>:<span class="dv">50</span>,<span class="dv">2</span>], </span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'red'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">0</span>], dataset[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">2</span>], </span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'green'</span>, marker <span class="op">=</span> <span class="st">'^'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">100</span>:<span class="dv">150</span>,<span class="dv">0</span>], dataset[<span class="dv">100</span>:<span class="dv">150</span>,<span class="dv">2</span>], </span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'blue'</span>, marker <span class="op">=</span> <span class="st">'*'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Kelchblattlaenge (cm)'</span>)</span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Kronblattlaenge (cm)'</span>)</span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-59"><a href="#cb39-59" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>)</span>
<span id="cb39-60"><a href="#cb39-60" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">0</span>:<span class="dv">50</span>,<span class="dv">1</span>], dataset[<span class="dv">0</span>:<span class="dv">50</span>,<span class="dv">3</span>], </span>
<span id="cb39-61"><a href="#cb39-61" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'red'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-62"><a href="#cb39-62" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">1</span>], dataset[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">3</span>], </span>
<span id="cb39-63"><a href="#cb39-63" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'green'</span>, marker <span class="op">=</span> <span class="st">'^'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-64"><a href="#cb39-64" aria-hidden="true" tabindex="-1"></a>ax.scatter(dataset[<span class="dv">100</span>:<span class="dv">150</span>,<span class="dv">1</span>], dataset[<span class="dv">100</span>:<span class="dv">150</span>,<span class="dv">3</span>], </span>
<span id="cb39-65"><a href="#cb39-65" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="st">'blue'</span>, marker <span class="op">=</span> <span class="st">'*'</span>, s <span class="op">=</span> <span class="dv">20</span>, alpha <span class="op">=</span> <span class="fl">0.6</span>)</span>
<span id="cb39-66"><a href="#cb39-66" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Kelchblattbreite (cm)'</span>)</span>
<span id="cb39-67"><a href="#cb39-67" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Kronblattbreite (cm)'</span>)</span>
<span id="cb39-68"><a href="#cb39-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-69"><a href="#cb39-69" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-imageirisscatterplot" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="aad_files/figure-html/fig-imageirisscatterplot-output-1.png" width="589" height="433" class="figure-img"></p>
<p></p><figcaption class="figure-caption">Abbildung&nbsp;5.7: Scatter Plots der Fisher Iris Daten</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Nun wählen wir uns aus den 150 Einträgen des Datensatzes zufällig 30 heraus, welche wir als Testdaten verwenden. Die übrigen 120 Einträge dienen uns als Trainingsdaten, mit denen wir unser neuronales Netz trainieren werden.</p>
<div class="cell" data-execution_count="31">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Daten in Trainings- und Testdaten aufteilen</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> dataset[:, <span class="dv">0</span>:<span class="dv">4</span>] <span class="co"># Messwerte</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> dataset[:, <span class="dv">4</span>]   <span class="co"># Label</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>allData <span class="op">=</span> np.arange(<span class="dv">0</span>, X.shape[<span class="dv">0</span>])</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>testIndices <span class="op">=</span> np.random.choice(X.shape[<span class="dv">0</span>], size <span class="op">=</span> <span class="dv">30</span>, replace <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>trainIndices <span class="op">=</span> np.delete(allData, testIndices)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>dataRecords <span class="op">=</span> <span class="bu">len</span>(testIndices)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>XTrain <span class="op">=</span> X[trainIndices, :]</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>YTrain <span class="op">=</span> np.array(Y[trainIndices], dtype <span class="op">=</span> np.int32)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>XTest <span class="op">=</span> X[testIndices, :]</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>YTest <span class="op">=</span> Y[testIndices]</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Unser Netz soll aus 4 Inputneuronen und 3 Outputneuronen bestehen. Die vier Inputs stehen für die vier Messwerte <code>X[0], ..., X[3]</code>. Wenn dort die entsprechenden Messwerte eingegeben wurden, dann werden bei den Outputneuronen <code>Y[0], ..., Y[2]</code> vier Werte zwischen <span class="math inline">\(0\)</span> und <span class="math inline">\(1\)</span> generiert, welche die Wahrscheinlichkeiten darstellen, dass es sich um die entsprechende Lilienart handelt. Das Neuron mit dem grössten Wert stellt unsere Vorhersage dar. Das neuronale Netz hat also die folgende Architektur:</p>
<div class="cell" data-fig-width="4">
<div class="cell-output-display">
<div id="fig-FisherNNArchitecture" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p>
<svg width="384" height="480" viewbox="0.00 0.00 72.00 118.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 114)"> <polygon fill="white" stroke="transparent" points="-4,4 -4,-114 68,-114 68,4 -4,4"></polygon> <!-- x0 --> <g id="node1" class="node">
<title>
x0
</title>
<ellipse fill="none" stroke="black" cx="7" cy="-39" rx="7" ry="7"></ellipse> </g> <!-- y0 --> <g id="node5" class="node">
<title>
y0
</title>
<ellipse fill="none" stroke="black" cx="57" cy="-87" rx="7" ry="7"></ellipse> </g> <!-- x0&#45;&#45;y0 --> <g id="edge1" class="edge">
<title>
x0–y0
</title>
<path fill="none" stroke="black" d="M12.43,-43.43C21.53,-52.53 42.23,-73.23 51.44,-82.44"></path> </g> <!-- y1 --> <g id="node6" class="node">
<title>
y1
</title>
<ellipse fill="none" stroke="black" cx="57" cy="-55" rx="7" ry="7"></ellipse> </g> <!-- x0&#45;&#45;y1 --> <g id="edge2" class="edge">
<title>
x0–y1
</title>
<path fill="none" stroke="black" d="M13.89,-40.96C23.1,-44.03 40.82,-49.94 50.07,-53.02"></path> </g> <!-- y2 --> <g id="node7" class="node">
<title>
y2
</title>
<ellipse fill="none" stroke="black" cx="57" cy="-23" rx="7" ry="7"></ellipse> </g> <!-- x0&#45;&#45;y2 --> <g id="edge3" class="edge">
<title>
x0–y2
</title>
<path fill="none" stroke="black" d="M13.89,-37.04C23.1,-33.97 40.82,-28.06 50.07,-24.98"></path> </g> <!-- x1 --> <g id="node2" class="node">
<title>
x1
</title>
<ellipse fill="none" stroke="black" cx="7" cy="-7" rx="7" ry="7"></ellipse> </g> <!-- x1&#45;&#45;y0 --> <g id="edge4" class="edge">
<title>
x1–y0
</title>
<path fill="none" stroke="black" d="M11.45,-12.75C20.31,-27.51 43.76,-66.6 52.58,-81.3"></path> </g> <!-- x1&#45;&#45;y1 --> <g id="edge5" class="edge">
<title>
x1–y1
</title>
<path fill="none" stroke="black" d="M12.43,-11.43C21.53,-20.53 42.23,-41.23 51.44,-50.44"></path> </g> <!-- x1&#45;&#45;y2 --> <g id="edge6" class="edge">
<title>
x1–y2
</title>
<path fill="none" stroke="black" d="M13.89,-8.96C23.1,-12.03 40.82,-17.94 50.07,-21.02"></path> </g> <!-- x2 --> <g id="node3" class="node">
<title>
x2
</title>
<ellipse fill="none" stroke="black" cx="7" cy="-103" rx="7" ry="7"></ellipse> </g> <!-- x2&#45;&#45;y0 --> <g id="edge7" class="edge">
<title>
x2–y0
</title>
<path fill="none" stroke="black" d="M13.89,-101.04C23.1,-97.97 40.82,-92.06 50.07,-88.98"></path> </g> <!-- x2&#45;&#45;y1 --> <g id="edge8" class="edge">
<title>
x2–y1
</title>
<path fill="none" stroke="black" d="M12.43,-98.57C21.53,-89.47 42.23,-68.77 51.44,-59.56"></path> </g> <!-- x2&#45;&#45;y2 --> <g id="edge9" class="edge">
<title>
x2–y2
</title>
<path fill="none" stroke="black" d="M11.45,-97.25C20.31,-82.49 43.76,-43.4 52.58,-28.7"></path> </g> <!-- x3 --> <g id="node4" class="node">
<title>
x3
</title>
<ellipse fill="none" stroke="black" cx="7" cy="-71" rx="7" ry="7"></ellipse> </g> <!-- x3&#45;&#45;y0 --> <g id="edge10" class="edge">
<title>
x3–y0
</title>
<path fill="none" stroke="black" d="M13.89,-72.96C23.1,-76.03 40.82,-81.94 50.07,-85.02"></path> </g> <!-- x3&#45;&#45;y1 --> <g id="edge11" class="edge">
<title>
x3–y1
</title>
<path fill="none" stroke="black" d="M13.89,-69.04C23.1,-65.97 40.82,-60.06 50.07,-56.98"></path> </g> <!-- x3&#45;&#45;y2 --> <g id="edge12" class="edge">
<title>
x3–y2
</title>
<path fill="none" stroke="black" d="M12.43,-66.57C21.53,-57.47 42.23,-36.77 51.44,-27.56"></path> </g> </g>
</svg>
</p>
<p></p><figcaption class="figure-caption">Abbildung&nbsp;5.8: Neuronales Netz für den Lilienklassifikator.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Entlang jeder Kante multiplizeren wir den Wert <span class="math inline">\(x_i\)</span> mit einem Gewicht <span class="math inline">\(w_{ij}\)</span> und addieren die vier Werte. Zu dieser Summe addieren wir noch einen Bias <span class="math inline">\(b_i\)</span> so entstehen drei Zwischenwerte <span class="math display">\[
z_i = \sum_{j=0}^3 w_{ij}x_j + b_i \quad\textrm{für}\quad i\in\lbrace0, 1, 2\rbrace
\]</span> In Matrixschreibweise können wir das ausdrücken als <span class="math display">\[
\vec{z} = W\cdot \vec{x} + \vec{b}
\]</span> mit <span class="math inline">\(W\in \mathbb{R}^{3\times 4}\)</span>, <span class="math inline">\(\vec{x}\in\mathbb{R}^4\)</span> und <span class="math inline">\(\vec{b}, \vec{z} \in \mathbb{R}^3\)</span>. Die Zwischenwerten <span class="math inline">\(z_i\)</span> müssen nun noch so skaliert werden, dass sie eine Wahrscheinlichkeitsverteilung darstellen. Das erreichen wir, die Softmax Funktion anwenden: <span class="math display">\[
\hat y_i = \sigma_i(\vec z) = \frac{e^{z_i}}{\sum_{k=0}^2 e^{z_k}} \quad\textrm{für}\quad i\in\lbrace0, 1, 2\rbrace
\]</span> Mehr zur Softmax Funktion findet man z.B. in <span class="citation" data-cites="Frochte2021">Frochte (<a href="references.html#ref-Frochte2021" role="doc-biblioref">2021</a>)</span> (S. 240). Im folgenden Programm unterscheiden wir noch, ob wir die Funktion auf einen Vektor aus Zahlen oder einen Vektor aus <code>FloatAad</code>-Objekten anwenden.</p>
<div class="cell" data-execution_count="32">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Softmax Funktion für Vektor z</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> softmax(z):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> z.dtype <span class="op">==</span> <span class="st">"object"</span>:</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [mathaad.exp(x) <span class="op">/</span> <span class="bu">sum</span>(mathaad.exp(z)) <span class="cf">for</span> x <span class="kw">in</span> z]</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [np.exp(x) <span class="op">/</span> <span class="bu">sum</span>(np.exp(z)) <span class="cf">for</span> x <span class="kw">in</span> z]</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Unsere Vorhersage ist dann der Wert <span class="math display">\[
y = \operatorname{argmax} \hat y_i \in \lbrace0, 1, 2\rbrace
\]</span></p>
<p>Die Frage ist also, wie wir die 12 Gewichte <span class="math inline">\(w_{ij}\)</span> und die Bias <span class="math inline">\(b_i\)</span> wählen. Letztere setzen wir einfach auf <span class="math inline">\(b_i = 1\)</span> für alle <span class="math inline">\(i\)</span>. Bei der Bestimmung der Gewichte kommen unsere Trainingsdaten ins Spiel. Wir definieren uns eine Loss Funktion <span class="math inline">\(J : \mathbb{R}^{12} \rightarrow \mathbb{R}\)</span>, welche als Input die Gewichte <span class="math inline">\(W\)</span> erhält und als Output die so genannte Cross-Entropy liefert, welche ein Mass für die Abweichung von der korrekten Klassifikation ist. Sie wird bestimmt, indem man zuerst <span class="math display">\[
D(\vec y, \vec {\hat y}) = - \sum_i y_i\cdot \ln(\hat y_i)
\]</span> berechnet, wobei die <span class="math inline">\(\hat y_i\)</span> wie oben definiert sind und <span class="math inline">\(\vec y = (y_i)_{i=0, 1, 2}\)</span> die One-Hot Codierung der korrekten Labels ist, d.h. <span class="math display">\[\begin{align*}
    \vec y &amp;= (\matrix{1, 0, 0})^\intercal \quad\textrm{falls der korrekte Label 0 (Iris setosa) ist,} \\
    \vec y &amp;= (\matrix{0, 1, 0})^\intercal \quad\textrm{falls der korrekte Label 1 (Iris versicolor) ist,} \\
    \vec y &amp;= (\matrix{0, 0, 1})^\intercal \quad\textrm{falls der korrekte Label 2 (Iris virginica) ist.}
\end{align*}\]</span></p>
<p>Die Cross-Entropy über alle <span class="math inline">\(N=120\)</span> Beispiele erhält man dann als Mittelwert dieser Grössen <span class="math display">\[
J(W) = \frac{1}{N}\sum_{n=0}^{N-1} D(\vec y^{(n)}, \vec{\hat y}^{(n)})
\]</span> Weitere Details zur Cross-Entropy findet man ebenfalls in <span class="citation" data-cites="Frochte2021">Frochte (<a href="references.html#ref-Frochte2021" role="doc-biblioref">2021</a>)</span> (S. 241). In der Python Funktion wandeln wir die Gewichte zuerst in <code>FloatAad</code>-Objete um und geben am Schluss den Wert <span class="math inline">\(J(W)\)</span> und die den Gradienten <span class="math inline">\(\nabla J (W)\)</span> zurück.</p>
<div class="cell" data-execution_count="33">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loss(Weights, bias, XTrain, YTrain):</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(YTrain) <span class="co"># Anzahl Trainingsdaten</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Gewichte als FloatAad-Matrix</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    Wtemp <span class="op">=</span> float2FloatAad(Weights)</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    WtempMatrix <span class="op">=</span> np.reshape(Wtemp, [<span class="dv">4</span>, <span class="dv">3</span>])</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Labels als One-Hot Encoding</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    YOneHot <span class="op">=</span> np.zeros([N, <span class="dv">3</span>])</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    YOneHot[<span class="bu">range</span>(N), YTrain] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    Z <span class="op">=</span> XTrain <span class="op">@</span> WtempMatrix <span class="op">+</span> bias</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Softmax auf jede Zeile anwenden</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    Yhat <span class="op">=</span> np.apply_along_axis(softmax, <span class="dv">1</span>, Z)</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cross Entropy</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> [<span class="op">-</span> YOneHot[i] <span class="op">@</span> mathaad.log(Yhat[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N) ]</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    J <span class="op">=</span> <span class="bu">sum</span>(D) <span class="op">/</span> N</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    LossValue <span class="op">=</span> getValues(J)</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>    LossGrad <span class="op">=</span> np.array(getGradient(Wtemp, J))</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [LossValue, LossGrad]</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Man beachte, dass das Matrixprodukt in der Zeile <code>Z = XTrain @ WtempMatrix + bias</code> eigentlich <span class="math inline">\(X\cdot W^\intercal + \vec b^\intercal\)</span> ist, mit <span class="math inline">\(X\in\mathbb{R}^{120\times 4}\)</span> und <span class="math inline">\(W^\intercal \in \mathbb{R}^{4\times 3}\)</span>. Die Addition von <code>bias</code> wird wird dann auf jede Zeile <span class="math inline">\(X\cdot W^\intercal \in \mathbb{R}^{120\times 3}\)</span> angewendet.</p>
<p>Nun verwenden wir wieder das Gradient Descent Verfahren, um ein lokales Minimum der Loss Funktion zu finden und damit die Gewichte zu optimieren. Wir initialisieren die Gewichte mit zufälligen Werten.</p>
<div class="cell" data-execution_count="34">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Gewichte initialisieren</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.random.random(<span class="dv">4</span> <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.ones(<span class="dv">3</span>)  <span class="co"># bias</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit mit Gradient Descent</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>lam <span class="op">=</span> <span class="fl">0.5</span> <span class="co"># Lernrate</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">1e-2</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time()</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>[Lval, Lgrad] <span class="op">=</span> loss(W, b, XTrain, YTrain)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> np.linalg.norm(Lgrad) <span class="op">&gt;</span> tol:</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    W1 <span class="op">=</span> W <span class="op">-</span> lam <span class="op">*</span> Lgrad</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    [Lval, Lgrad] <span class="op">=</span> loss(W1, b, XTrain, YTrain)</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> W1</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time()</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>zeit <span class="op">=</span> end <span class="op">-</span> start</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Der Lernprozess dauerte </span><span class="sc">%1.2f</span><span class="st"> Sekunden."</span> <span class="op">%</span>zeit)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Der Lernprozess dauerte 11.14 Sekunden.</code></pre>
</div>
</div>
<p>Zum Schluss wenden wir die Matrix mit den optimierten Gewichten auf die 30 Testdaten an, welche wir im Trainingsprozess noch nicht verwendet hatten, und zählen, wie viele davon durch unser Netz korrekt klassifiziert werden.</p>
<div class="cell" data-execution_count="35">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Test des Modells</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.reshape(W, [<span class="dv">4</span>, <span class="dv">3</span>])</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> XTest <span class="op">@</span> W <span class="op">+</span> b</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>Yp <span class="op">=</span> Yp <span class="op">=</span> np.apply_along_axis(softmax, <span class="dv">1</span>, Z)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> np.apply_along_axis(np.argmax, <span class="dv">1</span>, Yp)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Vergleich mit Resultaten</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>nCorrect <span class="op">=</span> <span class="bu">sum</span>(Y <span class="op">==</span> YTest)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="sc">%d</span><span class="st"> von </span><span class="sc">%d</span><span class="st"> wurden korrekt klassifiziert."</span> <span class="op">%</span>(nCorrect, dataRecords))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>28 von 30 wurden korrekt klassifiziert.</code></pre>
</div>
</div>
<p>Das vollständige Program kann <a href="FisherClassification.py">hier</a> heruntergeladen werden.</p>


<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography" style="display: none">
<div id="ref-Arens2022" class="csl-entry" role="doc-biblioentry">
Arens, Tilo, Frank Hettlich, Christian Karpfinger, Ulrich Kockelkorn, Klaus Lichtenegger, und Hellmuth Stachel. 2022. <em>Mathematik</em>. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-Hromkovic2022" class="csl-entry" role="doc-biblioentry">
Barot, Michael, Britta Dorn, Ghislain Fourny, Jens Gallenbacher, Juraj Hromkovic, und Regula Lacher. 2022. <em><span>INFORMATIK</span>, Data Science und Sicherheit: Grundlagen der Informatik f<span>ü</span>r Schweizer Maturit<span>ä</span>tsschulen</em>. Klett.
</div>
<div id="ref-Baydin18" class="csl-entry" role="doc-biblioentry">
Baydin, Atilim Gunes, Barak A. Pearlmutter, Alexey Andreyevich Radul, und Jeffrey Mark Siskind. 2018. <span>„Automatic Differentiation in Machine Learning: a Survey“</span>. <em>Journal of Machine Learning Research</em> 18 (153): 1–43. <a href="http://jmlr.org/papers/v18/17-468.html">http://jmlr.org/papers/v18/17-468.html</a>.
</div>
<div id="ref-Fisher1936" class="csl-entry" role="doc-biblioentry">
Fisher, R. A. 1936. <span>„Iris“</span>. UC Irvine Machine Learning Repository. 1936. <a href="https://archive-beta.ics.uci.edu/dataset/53/iris">https://archive-beta.ics.uci.edu/dataset/53/iris</a>.
</div>
<div id="ref-Frochte2021" class="csl-entry" role="doc-biblioentry">
Frochte, Jörg. 2021. <em>Maschinelles Lernen - Grundlagen und Algorithmen in Python</em>. 3. Aufl. Hanser.
</div>
<div id="ref-Griewank2008EDP" class="csl-entry" role="doc-biblioentry">
Griewank, Andreas, und Andrea Walther. 2008. <em>Evaluating Derivatives: <span>P</span>rinciples and Techniques of Algorithmic Differentiation</em>. 2. Aufl. Other Titles in Applied Mathematics 105. Philadelphia, PA: SIAM. <a href="http://bookstore.siam.org/ot105/">http://bookstore.siam.org/ot105/</a>.
</div>
<div id="ref-Henrard2017ADi" class="csl-entry" role="doc-biblioentry">
Henrard, Marc. 2017. <em>Algorithmic Differentiation in Finance Explained</em>. Financial Engineering Explained. Cham: Palgrave Macmillan. <a href="https://doi.org/10.1007/978-3-319-53979-9">https://doi.org/10.1007/978-3-319-53979-9</a>.
</div>
<div id="ref-sidsite2021" class="csl-entry" role="doc-biblioentry">
Radcliffe, Sidney. 2021. <span>„Reverse-mode automatic differentiation from scratch, in Python“</span>. 22. Mai 2021. <a href="https://sidsite.com/posts/autodiff/">https://sidsite.com/posts/autodiff/</a>.
</div>
<div id="ref-Slater2022" class="csl-entry" role="doc-biblioentry">
Slater, Max. 2022. <span>„Differentiable programming from scratch“</span>. Juli 2022. <a href="https://thenumb.at/Autodiff/">https://thenumb.at/Autodiff/</a>.
</div>
</div>
</section>
</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./HigherDimFunctions.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Funktionen mit mehreren In- und Outputs</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>