---
tbl-cap-location: bottom
---


# Ableitungen und ihre Anwendungen

## Ableitungen von Funktionen

Wir kennen Ableitungen von Funktionen $f: \mathbb{R}\rightarrow\mathbb{R}$ aus dem Mathematikunterricht. Sie geben uns darüber Auskunft, wie gross die Steigung der Tangente in einem bestimmten Punkt des Funktionsgraphen ist. Die Tangente stellt dabei die beste lineare Annäherung an den Funktionsgraph dar. Ableitungen beschreiben auch die lokale Änderungsrate der Funktion. Ableitungen erlauben es uns ausserdem, die Extrema und Wendepunkte einer Funktion zu bestimmen. 

Die folgende Tabelle fasst die bekannten Ableitungen der Grundfunktionen zusammen.

| $f(x)$                    | $f'(x)$                                 |     | $f(x)$                 | $f'(x)$                                 |
|---------------------------|-----------------------------------------|-----|------------------------|-----------------------------------------|
| $x^n$                     | $n \cdot x^n \quad (n\in\mathbb{R})$    |     | $\sqrt{x}$             | $\frac{1}{2\cdot\sqrt{x}}$              |
| $e^x$                     | $e^x$                                   |     | $a^x$                  | $a^x \cdot \ln(a) \quad (a>0, a\ne 1)$  |
| $\ln(x)$                  | $\frac{1}{x}$                           |     | $\log_a(x)$            | $\frac{1}{x\cdot\ln(a)}$                |
| $\sin(x)$                 | $\cos(x)$                               |     | $\arcsin(x)$           | $\frac{1}{\sqrt{1-x^2}}$                |
| $\cos(x)$                 | $-\sin(x)$                              |     | $\arccos(x)$           | $-\frac{1}{sqrt{1-x^2}}$                |
| $\tan(x)$                 | $\frac{1}{\cos^2(x)} = 1 + \tan^2(x)$   |     | $\arctan(x)$           | $\frac{1}{x^2+1}$                       |
| $\sinh(x)$                | $\cosh(x)$                              |     | $\textrm{arsinh}(x)$   | $\frac{1}{\sqrt{x^2+1}}$                |
| $\cosh(x)$                | $\sinh(x)$                              |     | $\textrm{arcosh(x)}$   | $\frac{1}{\sqrt{x^2-1}}$                |
| $\tanh(x)$                | $\frac{1}{\cosh^2(x)} = 1 - \tanh^2(x)$ |     | $\textrm{artanh(x)}$   | $-\frac{1}{x^2-1}$                      |

: Ableitungen der Grundfunktionen {#tbl-DiffGrundfunktionen}

Neue Funktionen erhält man, indem man die Grundfunktionen aus @tbl-DiffGrundfunktionen addiert, subtrahiert, multipliziert, dividiert und komponiert, d.h. Verkettungen der Form $(f\circ g)(x) = f(g(x))$ bildet. Um solche Funktionen abzuleiten brauchen wir die Regeln aus @tbl-DiffRegeln unten. Mit diesen Regeln sind wir dann schon in der Lage, alle differenzierbaren Funktionen abzuleiten.

|     |     |
| --- | --- |
| Summenregel     | $\frac{d}{dx}(f(x)\pm g(x)) = f'(x) \pm g'(x)$ |
| Produktregel <br> *Spezialfall: Faktorregel*    | $\frac{d}{dx}(f(x)\cdot g(x)) = f'(x)\cdot g(x) + f(x) \cdot g'(x)$ <br> $\frac{d}{dx}(a\cdot f(x)) = a\cdot f'(x)$ |
| Quotientenregel | $\frac{d}{dx}\frac{f(x)}{g(x)} = \frac{f'(x)\cdot g(x) - f(x) \cdot g'(x)}{g(x)^2}$  |
| Kettenregel     | $\frac{d}{dx} f(g(x)) = f'(g(x))\cdot g'(x)$  |

: Ableitungsregeln {#tbl-DiffRegeln}

An dieser Stelle sei noch angemerkt, dass sich der Begriff der Ableitung sinngemäss auf Funktionen $f: \mathbb{R}^n \rightarrow\mathbb{R}^m$ verallgemeinern lässt. Eine kurze Beschreibung der Grundidee findet sich in @Slater2022. Weitergehende Informationen findet man z.B. in @Arens2022 oder jedem Lehrbuch zur Analysis 2.


## Programme als Funktionen

Programme, die numerische Werte einlesen und numerische Werte ausgeben, können als mathematische Funktionen betrachtet werden. Wir beschränken uns zunächst auf Programme, die nur ein Argument erhalten und nur einen Rückgabewert liefern, z.B.
```{python}
#| eval: false
#| code-fold: false
def f(x):
    y = (2 + x) * (x - 3)
    return y

x0 = 2
print( f(x0) )
```

Diese Python-Funktion entspricht einer Funktion $f:\mathbb{R}\rightarrow\mathbb{R}$ im Sinne der Mathematik. Natürlich kann der Funktionskörper viel komplizierter aufgebaut sein und z.B. Schleifen und Bedingungen enthalten. 

Um zu verstehen, wie der Computer einen Ausdruck wie `y = (2 + x) * (x - 3)` auswertet, ist es hilfreich, ihn als Baum (im Sinne der Graphentheorie) darzustellen. Ausdrucksbäume werden z.B. in @Hromkovic2021 erklärt.

```{dot}
//| label: fig-compTreeSimple
//| fig-cap: Ausdrucksbaum zum Ausdruck `y = (2 + x) * (x - 3)`.
digraph "" {
    rankdir=BT
    fontname="Consolas"
    node [fontname="Consolas", fontsize=8, width=".2", height=".2", margin=.02]
    edge [fontname="Consolas", fontsize=8, arrowsize=0.5, len=minlen]
    graph[fontsize=8];


    nx [label = "x", shape = none];
    n2 [label = "2", shape = none];
    n3 [label = "3", shape = none];
    nPlus [label = "+", shape = circle];
    nMinus [label = "-", shape = circle];
    nMult [label = "*", shape = circle];
    ny [label = "y", shape = none];

    n2 -> nPlus;
    nx -> nPlus;
    nx -> nMinus;
    n3 -> nMinus;
    nPlus -> nMult;
    nMinus -> nMult;
    nMult -> ny;

}
```

Wir wollen nun unsere Python-Funktion so umschreiben, dass diese Struktur auch im Funktionskörper sichtbar wird. Dazu führen wir drei Hilfsvariablen `v0, v1, v2` ein.

```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    v1 = 2 + v0
    v2 = v0 - 3
    y = v1 * v2
    return y
```

:::{.callout-important}

## Konvention

Eine Funktion berechnet aus einem Argument `x` einen Rückgabewert `y` über eine Reihe von Hilfsvariablen `v`, die mit verschiedenen Indizes versehen sind. Dabei setzen wir am Anfang immer `v0 = x`.

:::

:::{#exr-ProgToFun}

## Programm in Funktion übersetzen
  
Schreibe die mathematische Funktion auf, die durch das folgende Programm berechnet wird.
```{python}
#| eval: false
#| code-fold: false
import math

def f(x):
    v0 = x
    v1 = v0 ** 2
    v2 = v1 + 2
    v3 = -v1 / 2
    v4 = math.cos(v2)
    v5 = math.exp(v3)
    v6 = v4 * v5
    y = v6 + 1 / v0
    return y 
```

:::

:::{.callout-tip collapse="true"}

## Lösung

$$
\begin{flalign}
v_1 & = x^2 \\
v_2 & = x^2 + 2 \\
v_3 & = - \frac{x^2}{2} \\
v_4 & = \cos(x^2 + 2) \\
v_5 & = e^{- \frac{x^2}{2}} \\
v_6 & = \cos(x^2 + 2) \cdot e^{- \frac{x^2}{2}} \\
y & = f(x) = \cos(x^2 + 2) \cdot e^{- \frac{x^2}{2}} + \frac{1}{x} \\
\end{flalign}
$$

:::

:::{#exr-FunToGraphProg}

## Funktion in Graph und Programm übersetzen
  
Schreibe zur mathematischen Funktion $y = f(x) = \frac{\ln(x^2 + 1)}{\sqrt{x^2 + 1 + x}}$ den Ausdrucksbaum auf.
Übersetze den Ausdruck anschliessend in eine Python-Funktion gemäss der Konvention.

:::

:::{.callout-tip collapse="true"}

## Lösung

```{dot}
//| label: fig-compTreeSimple
//| fig-cap: Ausdrucksbaum zum Ausdruck `y = ln(x^2 + 1) / sqrt(x^2 + 1 + x)`.
digraph "" {
    rankdir=LR
    fontname="Consolas"
    node [fontname="Consolas", fontsize=8, width=".2", height=".2", margin=.02]
    edge [fontname="Consolas", fontsize=8, arrowsize=0.5, len=minlen]
    graph[fontsize=8];


    nx [label = "x", shape = none];
    n2 [label = "2", shape = none];
    n1 [label = "1", shape = none];
    nPlus1 [label = "+", shape = circle];
    nPlus2 [label = "+", shape = circle];
    nPow [label = "^", shape = circle];
    nFrac [label = "/", shape = circle];
    nLog [label = "ln( )", shape = circle];
    nSqrt [label = "sqrt( )", shape = circle];
    ny [label = "y", shape = none];

    nx -> nPow;
    n2 -> nPow;
    nPow -> nPlus1;
    n1 -> nPlus1;
    nx -> nPlus2;
    nPlus1 -> nPlus2;
    nPlus1 -> nLog;
    nPlus2 -> nSqrt;
    nLog -> nFrac;
    nSqrt -> nFrac;
    nFrac -> ny;
}
```

```{python}
#| eval: false
import math

def f(x):
    v0 = x
    v1 = v0 ** 2
    v2 = v1 + 1
    v3 = v2 + v0
    v4 = math.log(v2)
    v5 = math.sqrt(v3)
    y = v4 / v5
    return y
```
:::

:::{#exr-LoopProgToFun}

## Ein Programm mit einer Schleife

Ersetze im Funktionskörper die Schleife durch mehrere Befehle, so dass immer noch der gleiche mathematische Ausdruck berechnet wird und unsere Konvention eingehalten wird. Welche mathematische Funktion wird durch die Python-Funktion berechnet?
Was ändert sich, wenn stattdessen `for i in range(3)` oder `for i in range(4)` stehen würde? 

```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    for i in range(2):
        v0 = v0 ** 2 + 1
    y = v0
    return y
```

:::

:::{.callout-tip collapse="true"}

## Lösung

Für jeden Schleifendurchgang benötigen wir eine neue Hilfsvariable.

::::{.panel-tabset}

## `range(2)`
```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    v1 = v0 ** 2 + 1
    v2 = v1 ** 2 + 1
    y = v2
    return y
```
$f(x) = (x^2 + 1)^2 + 1 = x^4 + 2x^2 + 2$


## `range(3)`
```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    v1 = v0 ** 2 + 1
    v2 = v1 ** 2 + 1
    v3 = v2 ** 2 + 1
    y = v3
    return y
```
$f(x) = ((x^2 + 1)^2 + 1)^2 + 1 = x^8 + 4x^6 + 8x^4 + 8x^2 + 5$

## `range(4)`
```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    v1 = v0 ** 2 + 1
    v2 = v1 ** 2 + 1
    v3 = v2 ** 2 + 1
    v4 = v3 ** 2 + 1
    y = v4
    return y
```
$$
\begin{flalign}
    f(x) &= (((x^2 + 1)^2 + 1)^2 + 1)^2 + 1 \\
         &= x^{16} + 8x^{14} + 32x^{12} + 80x^{10} + 138x^8 + 168x^6 + 144x^4 + 80x^2 + 26
\end{flalign}
$$

::::

:::



## Unser Ziel: Programme ableiten

COMING SOON


### Das Newtonverfahren zur Berechnung von Nullstellen


