---
tbl-cap-location: bottom
---


# Ableitungen und ihre Anwendungen

## Ableitungen von Funktionen

Wir kennen Ableitungen von Funktionen $f: \mathbb{R}\rightarrow\mathbb{R}$ aus dem Mathematikunterricht. Sie geben uns darüber Auskunft, wie gross die Steigung der Tangente in einem bestimmten Punkt des Funktionsgraphen ist. Die Tangente stellt dabei die beste lineare Annäherung an den Funktionsgraph dar. Ableitungen beschreiben auch die lokale Änderungsrate der Funktion. Ableitungen erlauben es uns ausserdem, die Extrema und Wendepunkte einer Funktion zu bestimmen. 

Die folgende Tabelle fasst die bekannten Ableitungen der Grundfunktionen zusammen.

| $f(x)$                    | $f'(x)$                                 |     | $f(x)$                 | $f'(x)$                                 |
|---------------------------|-----------------------------------------|-----|------------------------|-----------------------------------------|
| $x^n$                     | $n \cdot x^n \quad (n\in\mathbb{R})$    |     | $\sqrt{x}$             | $\frac{1}{2\cdot\sqrt{x}}$              |
| $e^x$                     | $e^x$                                   |     | $a^x$                  | $a^x \cdot \ln(a) \quad (a>0, a\ne 1)$  |
| $\ln(x)$                  | $\frac{1}{x}$                           |     | $\log_a(x)$            | $\frac{1}{x\cdot\ln(a)}$                |
| $\sin(x)$                 | $\cos(x)$                               |     | $\arcsin(x)$           | $\frac{1}{\sqrt{1-x^2}}$                |
| $\cos(x)$                 | $-\sin(x)$                              |     | $\arccos(x)$           | $-\frac{1}{\sqrt{1-x^2}}$                |
| $\tan(x)$                 | $\frac{1}{\cos^2(x)} = 1 + \tan^2(x)$   |     | $\arctan(x)$           | $\frac{1}{x^2+1}$                       |
| $\sinh(x)$                | $\cosh(x)$                              |     | $\textrm{arsinh}(x)$   | $\frac{1}{\sqrt{x^2+1}}$                |
| $\cosh(x)$                | $\sinh(x)$                              |     | $\textrm{arcosh(x)}$   | $\frac{1}{\sqrt{x^2-1}}$                |
| $\tanh(x)$                | $\frac{1}{\cosh^2(x)} = 1 - \tanh^2(x)$ |     | $\textrm{artanh(x)}$   | $-\frac{1}{x^2-1}$                      |

: Ableitungen der Grundfunktionen {#tbl-DiffGrundfunktionen}

Neue Funktionen erhält man, indem man die Grundfunktionen aus @tbl-DiffGrundfunktionen addiert, subtrahiert, multipliziert, dividiert und komponiert, d.h. Verkettungen der Form $(f\circ g)(x) = f(g(x))$ bildet. Um solche Funktionen abzuleiten brauchen wir die Regeln aus @tbl-DiffRegeln. Mit diesen Regeln sind wir dann schon in der Lage, alle differenzierbaren Funktionen abzuleiten.

|     |     |
| --- | --- |
| Summenregel     | $\frac{d}{dx}(f(x)\pm g(x)) = f'(x) \pm g'(x)$ |
| Produktregel <br> *Spezialfall: Faktorregel*    | $\frac{d}{dx}(f(x)\cdot g(x)) = f'(x)\cdot g(x) + f(x) \cdot g'(x)$ <br> $\frac{d}{dx}(a\cdot f(x)) = a\cdot f'(x)$ |
| Quotientenregel | $\frac{d}{dx}\frac{f(x)}{g(x)} = \frac{f'(x)\cdot g(x) - f(x) \cdot g'(x)}{g(x)^2}$  |
| Kettenregel     | $\frac{d}{dx} f(g(x)) = f'(g(x))\cdot g'(x)$  |

: Ableitungsregeln {#tbl-DiffRegeln}

An dieser Stelle sei noch angemerkt, dass sich der Begriff der Ableitung sinngemäss auf Funktionen $f: \mathbb{R}^n \rightarrow\mathbb{R}^m$ verallgemeinern lässt. Eine kurze Beschreibung der Grundidee findet sich in @Slater2022. Weitergehende Informationen findet man z.B. in @Arens2022 oder in jedem Lehrbuch zur Analysis 2.


## Programme als Funktionen

Programme, die numerische Werte einlesen und numerische Werte ausgeben, können als mathematische Funktionen betrachtet werden. Wir beschränken uns zunächst auf Programme, die nur ein Argument erhalten und nur einen Rückgabewert liefern, z.B.
```{python}
#| eval: false
#| code-fold: false
def f(x):
    y = (2 + x) * (x - 3)
    return y

x0 = 2
print( f(x0) )
```

Diese Python-Funktion entspricht der Funktion $f:\mathbb{R}\rightarrow\mathbb{R} , x \mapsto y=(2+x)(x-3)$ im Sinne der Mathematik. Natürlich kann der Funktionskörper viel komplizierter aufgebaut sein und z.B. Schleifen und Bedingungen enthalten. 

Um zu verstehen, wie der Computer einen Ausdruck wie `y = (2 + x) * (x - 3)` auswertet, ist es hilfreich, ihn als Baum (im Sinne der Graphentheorie) darzustellen. Ausdrucksbäume (*computational graphs*) werden z.B. in @Hromkovic2021 erklärt.

```{dot}
//| label: fig-compTreeSimple
//| fig-cap: Ausdrucksbaum zum Ausdruck `y = (2 + x) * (x - 3)`.
digraph "" {
    rankdir=BT
    fontname="Consolas"
    node [fontname="Consolas", fontsize=8, width=".2", height=".2", margin=.02]
    edge [fontname="Consolas", fontsize=8, arrowsize=0.5, len=minlen]
    graph[fontsize=8];


    nx [label = "x", shape = none];
    n2 [label = "2", shape = none];
    n3 [label = "3", shape = none];
    nPlus [label = "+", shape = circle];
    nMinus [label = "-", shape = circle];
    nMult [label = "*", shape = circle];
    ny [label = "y", shape = none];

    n2 -> nPlus;
    nx -> nPlus;
    nx -> nMinus;
    n3 -> nMinus;
    nPlus -> nMult;
    nMinus -> nMult;
    nMult -> ny;

}
```

Wir wollen nun unsere Python-Funktion so umschreiben, dass diese Struktur auch im Funktionskörper sichtbar wird. Dazu führen wir drei Hilfsvariablen `v0, v1, v2` ein.

```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    v1 = 2 + v0
    v2 = v0 - 3
    y = v1 * v2
    return y
```

:::{.callout-important}

## Konvention

Eine Funktion berechnet aus einem Argument `x` einen Rückgabewert `y` über eine Reihe von Hilfsvariablen `v`, die mit verschiedenen Indizes versehen sind. Dabei setzen wir am Anfang immer `v0 = x`.

:::

:::{#exr-ProgToFun}

## Programm in Funktion übersetzen
<br>

Schreibe die mathematische Funktion auf, die durch das folgende Programm berechnet wird.
```{python}
#| eval: false
#| code-fold: false
import math

def f(x):
    v0 = x
    v1 = v0 ** 2
    v2 = v1 + 2
    v3 = -v1 / 2
    v4 = math.cos(v2)
    v5 = math.exp(v3)
    v6 = v4 * v5
    y = v6 + 1 / v0
    return y 
```

:::

:::{.callout-tip collapse="true"}

## Lösung

$$
\begin{flalign}
v_1 & = x^2 \\
v_2 & = x^2 + 2 \\
v_3 & = - \frac{x^2}{2} \\
v_4 & = \cos(x^2 + 2) \\
v_5 & = e^{- \frac{x^2}{2}} \\
v_6 & = \cos(x^2 + 2) \cdot e^{- \frac{x^2}{2}} \\
y & = f(x) = \cos(x^2 + 2) \cdot e^{- \frac{x^2}{2}} + \frac{1}{x} \\
\end{flalign}
$$

:::

:::{#exr-FunToGraphProg}

## Funktion in Graph und Programm übersetzen
<br>

Schreibe zur mathematischen Funktion $y = f(x) = \frac{\ln(x^2 + 1)}{\sqrt{x^2 + 1 + x}}$ den Ausdrucksbaum auf.
Übersetze den Ausdruck anschliessend in eine Python-Funktion gemäss der Konvention.

:::

:::{.callout-tip collapse="true"}

## Lösung

```{dot}
//| label: fig-compTreeSimple
//| fig-cap: Computational Graph zum Ausdruck `y = ln(x^2 + 1) / sqrt(x^2 + 1 + x)`.
digraph "" {
    rankdir=LR
    fontname="Consolas"
    node [fontname="Consolas", fontsize=8, width=".2", height=".2", margin=.02]
    edge [fontname="Consolas", fontsize=8, arrowsize=0.5, len=minlen]
    graph[fontsize=8];


    nx [label = "x", shape = none];
    n2 [label = "2", shape = none];
    n1 [label = "1", shape = none];
    nPlus1 [label = "+", shape = circle];
    nPlus2 [label = "+", shape = circle];
    nPow [label = "^", shape = circle];
    nFrac [label = "/", shape = circle];
    nLog [label = "ln( )", shape = circle];
    nSqrt [label = "sqrt( )", shape = circle];
    ny [label = "y", shape = none];

    nx -> nPow;
    n2 -> nPow;
    nPow -> nPlus1;
    n1 -> nPlus1;
    nx -> nPlus2;
    nPlus1 -> nPlus2;
    nPlus1 -> nLog;
    nPlus2 -> nSqrt;
    nLog -> nFrac;
    nSqrt -> nFrac;
    nFrac -> ny;
}
```

```{python}
#| eval: false
import math

def f(x):
    v0 = x
    v1 = v0 ** 2
    v2 = v1 + 1
    v3 = v2 + v0
    v4 = math.log(v2)
    v5 = math.sqrt(v3)
    y = v4 / v5
    return y
```
:::

:::{#exr-LoopProgToFun}

## Ein Programm mit einer Schleife
<br>

Ersetze im Funktionskörper die Schleife durch mehrere Befehle, so dass immer noch der gleiche mathematische Ausdruck berechnet wird und unsere Konvention eingehalten wird. Welche mathematische Funktion wird durch die Python-Funktion berechnet?
Was ändert sich, wenn stattdessen `for i in range(3)` oder `for i in range(4)` stehen würde? 

```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    for i in range(2):
        v0 = v0 ** 2 + 1
    y = v0
    return y
```

:::

:::{.callout-tip collapse="true"}

## Lösung

Für jeden Schleifendurchgang benötigen wir eine neue Hilfsvariable.

::::{.panel-tabset}

## `range(2)`
```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    v1 = v0 ** 2 + 1
    v2 = v1 ** 2 + 1
    y = v2
    return y
```
$f(x) = (x^2 + 1)^2 + 1 = x^4 + 2x^2 + 2$


## `range(3)`
```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    v1 = v0 ** 2 + 1
    v2 = v1 ** 2 + 1
    v3 = v2 ** 2 + 1
    y = v3
    return y
```
$f(x) = ((x^2 + 1)^2 + 1)^2 + 1 = x^8 + 4x^6 + 8x^4 + 8x^2 + 5$

## `range(4)`
```{python}
#| eval: false
#| code-fold: false
def f(x):
    v0 = x
    v1 = v0 ** 2 + 1
    v2 = v1 ** 2 + 1
    v3 = v2 ** 2 + 1
    v4 = v3 ** 2 + 1
    y = v4
    return y
```
$$
\begin{flalign}
    f(x) &= (((x^2 + 1)^2 + 1)^2 + 1)^2 + 1 \\
         &= x^{16} + 8x^{14} + 32x^{12} + 80x^{10} + 138x^8 + 168x^6 + 144x^4 + 80x^2 + 26
\end{flalign}
$$

::::

:::



## Unser Ziel: Programme ableiten

Wie eingangs erwähnt wurde, haben Ableitungen viele nützliche Anwendungen. 

COMING SOON: Idee Programm als Funktion ableiten, Namensgebung AD, möglichst exakte Werte gesucht.


### Das Newtonverfahren zur Berechnung von Nullstellen

In vielen Anwendungen steht man vor der Aufgabe, die Gleichung $f(x) = 0$ nach $x$ aufzulösen, d.h. eine Nullstelle der Funktion zu finden. Oft ist es aber nicht möglich, die Lösung einer solchen Gleichung in geschlossener Form darzustellen. Um dennoch eine Lösung zumindest näherungsweise berechnen zu können, kann man folgendermassen vorgehen:

1. Wähle einen Startwert $x_0$, der in der Nähe einer Nullstelle $\bar{x}$ von $f$ liegt.
2. Im Kurvenpunkt $(x_0 | y_0)$ wird die Tangente an die Kurve $f$ gelegt. Deren Schnittpunkt $x_1$ mit der $x$-Achse liegt in der Regel näher bei $\bar{x}$ als $x_0$.
3. Nun wiederholt man das Verfahren, indem man bei $x_1$ die Tangente an die Kurve legt, usw. Auf diese Weise erhält man eine Folge von Näherungen $x_0, x_1, x_2, \ldots$, deren Grenzwert die Nullstelle $\bar{x}$ ist.

:::{.fig-NewtonGeoGebra}

<iframe scrolling="no" title="Newtonverfahren" src="https://www.geogebra.org/material/iframe/id/baja85gv/width/700/height/500/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/true/rc/false/ld/false/sdz/true/ctl/false" width="700px" height="500px" style="border:0px;"> </iframe>

:::

Die Gleichung der Tangente im Punkt $(x_n | y_n) = (x_n | f(x_n))$ ist bekanntlich $t(x) = f(x_n) + f'(x_n) \cdot (x - x_n)$. Die Nullstelle der Tangente ist der Näherungswert $x_{n+1}$. Aus $t(x_{n+1}) = 0$ ergibt sich nun 
$$
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
$$

:::{#exr-NewtonFirstTry}

## Das Newtonverfahren programmieren
<br>

Schreibe ein Programm, das mit Hilfe des Newtonverfahrens eine Nullstelle der Funktion $f(x) = \frac{1}{31} x^3 -\frac{1}{20} x^2 -x + 1$ berechnet. Verwende den Startwert $x_0 = -2$. Du kannst abbrechen, wenn die Differenz $|x_{n+1} - x_n|$ kleiner als eine bestimmte Toleranz wird, u.B. kleiner als `tol = 1e-6`.
Wie flexibel ist dein Programm einsetzbar? Überlege dir z.B., wie viele Änderungen du vornehmen müsstest, wenn du die Nullstelle einer anderen Funktion berechnen müsstest. 

:::

:::{.callout-tip collapse="true"}

## Lösung

Welche der folgenden Lösungsvorschläge kommt deinem Programm am nächsten?

::::{.panel-tabset}

## Newton als main-Programm (1)
```{python}
#| eval: true
#| code-fold: false
from math import fabs

x0 = -2
tol = 1e-6
# Erster Schritt berechnen
x1 = x0 - (1/31 * x0**3 - 1/20 * x0**2 - x0 + 1) / (3/31 * x0**2 - 1/10 * x0 - 1)
while fabs(x1 - x0) > tol:
    x0 = x1
    x1 = x0 - (1/31 * x0**3 - 1/20 * x0**2 - x0 + 1) / (3/31 * x0**2 - 1/10 * x0 - 1)
print(x1)
```
Das Newtonverfahren wird als main-Funktion (d.h. im Hauptprogramm) ausgeführt. Braucht man jedoch die Nullstelle einer anderen Funktion, dann muss ein neues Programm geschrieben werden. Die Ableitung wurde von Hand berechnet.


## Newton als main-Programm (2)
```{python}
#| eval: true
#| code-fold: false
from math import fabs

def f(x):
    y = 1/31 * x**3 - 1/20 * x**2 - x + 1
    return y

def fdot(x):
    y = 3/31 * x**2 - 1/10 * x - 1
    return y

x0 = -2
tol = 1e-6
# Erster Schritt berechnen
x1 = x0 - f(x0) / fdot(x0)
while fabs(x1 - x0) > tol:
    x0 = x1
    x1 = x0 - f(x0) / fdot(x0)
print(x1)
```
Das Newtonverfahren wird als main-Funktion (d.h. im Hauptprogramm) ausgeführt, aber die Berechnung von $f$ und ihrer Ableitung $f'$ wurde in zwei Funktionen `f` und `fdot` ausgelagert. Das macht das Programm übersichtlicher und flexibler. Die Ableitung wurde wieder von Hand berechnet.

## Newton als Funktion (1)
```{python}
#| eval: true
#| code-fold: false
from math import fabs

def newton(f, fdot, x0):
    tol = 1e-6
    # Erster Schritt berechnen
    x1 = x0 - f(x0) / fdot(x0)
    while fabs(x1 - x0) > tol:
        x0 = x1
        x1 = x0 - f(x0) / fdot(x0)
    return(x1)

def f(x):
    y = 1/31 * x**3 - 1/20 * x**2 - x + 1
    return y

def fdot(x):
    y = 3/31 * x**2 - 1/10 * x - 1
    return y

x0 = -2
xbar = newton(f, fdot, x0)
print(xbar)
```
Das Newtonverfahren wird als eigene Funktion implementiert, der die Funktion $f$ und ihre Ableitung $f'$, sowie der Startwert $x_0$ als Argumente übergeben werden. Diese Funktion kann dann im Hauptprogramm aufgerufen werden. Die Ableitung wurde aber immer noch von Hand berechnet.

## Newton als Funktion (2)
```{python}
#| eval: true
#| code-fold: false
from math import fabs

def newton(f, x0):
    tol = 1e-6
    # Erster Schritt berechnen
    # Ableitung von f an der Stelle x0 annähern
    h = 1e-6
    ydot = ( f(x0 + h) - f(x0) ) / h
    x1 = x0 - f(x0) / ydot
    while fabs(x1 - x0) > tol:
        x0 = x1
        ydot = ( f(x0 + h) - f(x0) ) / h
        x1 = x0 - f(x0) / ydot
    return(x1)

def f(x):
    y = 1/31 * x**3 - 1/20 * x**2 - x + 1
    return y

x0 = -2
xbar = newton(f, x0)
print(xbar)
```
Hier wird das Newtonverfahren in einer Funktion implementiert. Die Ableitung wird nicht mehr von Hand berechnet, sondern innerhalb der Funktion mit $f'(x_0)\approx \frac{f(x_0 + h) - f(x_0)}{h}$ angenähert. Dabei wird einfach `h = 1e-6` gesetzt und gehofft, dass der entstehende Rundungsfehler klein genug ist.


::::

:::

Auch die letzte vorgestellte Lösung ist noch nicht befriedigend. Als wir die Ableitung von Hand berechnet hatten, musste nur die Funktion `fdot` and der Stelle `x0` ausgewertet werden, um den (bis auf Maschinengenauigkeit) *exakten* Wert von $f'(x_0)$ zu erhalten. Bei der letzten Methode muss man sich mit einem Näherungswert der Ableitung zufrieden geben. Auch wenn der Wert in diesem Beispiel gut genug war[^1], so haben wir doch keine Garantie, dass wir für alle Funktionen einen vernünftigen Wert erhalten. Auf die Probleme, die mit dieser Annäherung von $f'(x_0)$ auftreten, wird in @sec-ADnotNumDiff näher eingegangen.

[^1]: Das Newton-Verfahren hat die angenehme Eigenschaft, dass kleine Rundungsfehler automatisch ausgeglichen werden. Auf andere numerische Verfahren, die die Ableitung verwenden, trifft dies aber nicht zu.

### Gradient Descent zum Auffinden lokaler Minima


