{"title":"Ableitungen und ihre Anwendungen","markdown":{"yaml":{"tbl-cap-location":"bottom"},"headingText":"Ableitungen und ihre Anwendungen","containsRefs":false,"markdown":"\n\n\n\n## Ableitungen von Funktionen\n\nWir kennen Ableitungen von Funktionen $f: \\mathbb{R}\\rightarrow\\mathbb{R}$ aus dem Mathematikunterricht. Sie geben uns darüber Auskunft, wie gross die Steigung der Tangente in einem bestimmten Punkt des Funktionsgraphen ist. Die Tangente stellt dabei die beste lineare Annäherung an den Funktionsgraph dar. Ableitungen beschreiben auch die lokale Änderungsrate der Funktion. Ableitungen erlauben es uns ausserdem, die Extrema und Wendepunkte einer Funktion zu bestimmen. \n\nDie folgende Tabelle fasst die bekannten Ableitungen der Grundfunktionen zusammen.\n\n| $f(x)$                    | $f'(x)$                                 |     | $f(x)$                 | $f'(x)$                                 |\n|---------------------------|-----------------------------------------|-----|------------------------|-----------------------------------------|\n| $x^n$                     | $n \\cdot x^n \\quad (n\\in\\mathbb{R})$    |     | $\\sqrt{x}$             | $\\frac{1}{2\\cdot\\sqrt{x}}$              |\n| $e^x$                     | $e^x$                                   |     | $a^x$                  | $a^x \\cdot \\ln(a) \\quad (a>0, a\\ne 1)$  |\n| $\\ln(x)$                  | $\\frac{1}{x}$                           |     | $\\log_a(x)$            | $\\frac{1}{x\\cdot\\ln(a)}$                |\n| $\\sin(x)$                 | $\\cos(x)$                               |     | $\\arcsin(x)$           | $\\frac{1}{\\sqrt{1-x^2}}$                |\n| $\\cos(x)$                 | $-\\sin(x)$                              |     | $\\arccos(x)$           | $-\\frac{1}{\\sqrt{1-x^2}}$                |\n| $\\tan(x)$                 | $\\frac{1}{\\cos^2(x)} = 1 + \\tan^2(x)$   |     | $\\arctan(x)$           | $\\frac{1}{x^2+1}$                       |\n| $\\sinh(x)$                | $\\cosh(x)$                              |     | $\\textrm{arsinh}(x)$   | $\\frac{1}{\\sqrt{x^2+1}}$                |\n| $\\cosh(x)$                | $\\sinh(x)$                              |     | $\\textrm{arcosh(x)}$   | $\\frac{1}{\\sqrt{x^2-1}}$                |\n| $\\tanh(x)$                | $\\frac{1}{\\cosh^2(x)} = 1 - \\tanh^2(x)$ |     | $\\textrm{artanh(x)}$   | $-\\frac{1}{x^2-1}$                      |\n\n: Ableitungen der Grundfunktionen {#tbl-DiffGrundfunktionen}\n\nNeue Funktionen erhält man, indem man die Grundfunktionen aus @tbl-DiffGrundfunktionen addiert, subtrahiert, multipliziert, dividiert und komponiert, d.h. Verkettungen der Form $(f\\circ g)(x) = f(g(x))$ bildet. Um solche Funktionen abzuleiten brauchen wir die Regeln aus @tbl-DiffRegeln. Mit diesen Regeln sind wir dann schon in der Lage, alle differenzierbaren Funktionen abzuleiten.\n\n|     |     |\n| --- | --- |\n| Summenregel     | $\\frac{d}{dx}(f(x)\\pm g(x)) = f'(x) \\pm g'(x)$ |\n| Produktregel <br> *Spezialfall: Faktorregel*    | $\\frac{d}{dx}(f(x)\\cdot g(x)) = f'(x)\\cdot g(x) + f(x) \\cdot g'(x)$ <br> $\\frac{d}{dx}(a\\cdot f(x)) = a\\cdot f'(x)$ |\n| Quotientenregel | $\\frac{d}{dx}\\frac{f(x)}{g(x)} = \\frac{f'(x)\\cdot g(x) - f(x) \\cdot g'(x)}{g(x)^2}$  |\n| Kettenregel     | $\\frac{d}{dx} f(g(x)) = f'(g(x))\\cdot g'(x)$  |\n\n: Ableitungsregeln {#tbl-DiffRegeln}\n\nAn dieser Stelle sei noch angemerkt, dass sich der Begriff der Ableitung sinngemäss auf Funktionen $f: \\mathbb{R}^n \\rightarrow\\mathbb{R}^m$ verallgemeinern lässt. Eine kurze Beschreibung der Grundidee findet sich in @Slater2022. Weitergehende Informationen findet man z.B. in @Arens2022 oder in jedem Lehrbuch zur Analysis 2.\n\n\n## Programme als Funktionen\n\nProgramme, die numerische Werte einlesen und numerische Werte ausgeben, können als mathematische Funktionen betrachtet werden. Wir beschränken uns zunächst auf Programme, die nur ein Argument erhalten und nur einen Rückgabewert liefern, z.B.\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    y = (2 + x) * (x - 3)\n    return y\n\nx0 = 2\nprint( f(x0) )\n```\n\nDiese Python-Funktion entspricht der Funktion $f:\\mathbb{R}\\rightarrow\\mathbb{R} , x \\mapsto y=(2+x)(x-3)$ im Sinne der Mathematik. Natürlich kann der Funktionskörper viel komplizierter aufgebaut sein und z.B. Schleifen und Bedingungen enthalten. \n\nUm zu verstehen, wie der Computer einen Ausdruck wie `y = (2 + x) * (x - 3)` auswertet, ist es hilfreich, ihn als Baum (im Sinne der Graphentheorie) darzustellen. Ausdrucksbäume (*computational graphs*) werden z.B. in @Hromkovic2021 erklärt.\n\n```{dot}\n//| label: fig-compTreeSimple\n//| fig-cap: Ausdrucksbaum zum Ausdruck `y = (2 + x) * (x - 3)`.\ndigraph \"\" {\n    rankdir=BT\n    fontname=\"Consolas\"\n    node [fontname=\"Consolas\", fontsize=8, width=\".2\", height=\".2\", margin=.02]\n    edge [fontname=\"Consolas\", fontsize=8, arrowsize=0.5, len=minlen]\n    graph[fontsize=8];\n\n\n    nx [label = \"x\", shape = none];\n    n2 [label = \"2\", shape = none];\n    n3 [label = \"3\", shape = none];\n    nPlus [label = \"+\", shape = circle];\n    nMinus [label = \"-\", shape = circle];\n    nMult [label = \"*\", shape = circle];\n    ny [label = \"y\", shape = none];\n\n    n2 -> nPlus;\n    nx -> nPlus;\n    nx -> nMinus;\n    n3 -> nMinus;\n    nPlus -> nMult;\n    nMinus -> nMult;\n    nMult -> ny;\n\n}\n```\n\nWir wollen nun unsere Python-Funktion so umschreiben, dass diese Struktur auch im Funktionskörper sichtbar wird. Dazu führen wir drei Hilfsvariablen `v0, v1, v2` ein.\n\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    v1 = 2 + v0\n    v2 = v0 - 3\n    y = v1 * v2\n    return y\n```\n\n:::{.callout-important}\n\n## Konvention\n\nEine Funktion berechnet aus einem Argument `x` einen Rückgabewert `y` über eine Reihe von Hilfsvariablen `v`, die mit verschiedenen Indizes versehen sind. Dabei setzen wir am Anfang immer `v0 = x`.\n\n:::\n\n:::{#exr-ProgToFun}\n\n## Programm in Funktion übersetzen\n<br>\n\nSchreibe die mathematische Funktion auf, die durch das folgende Programm berechnet wird.\n```{python}\n#| eval: false\n#| code-fold: false\nimport math\n\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2\n    v2 = v1 + 2\n    v3 = -v1 / 2\n    v4 = math.cos(v2)\n    v5 = math.exp(v3)\n    v6 = v4 * v5\n    y = v6 + 1 / v0\n    return y \n```\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n$$\n\\begin{flalign}\nv_1 & = x^2 \\\\\nv_2 & = x^2 + 2 \\\\\nv_3 & = - \\frac{x^2}{2} \\\\\nv_4 & = \\cos(x^2 + 2) \\\\\nv_5 & = e^{- \\frac{x^2}{2}} \\\\\nv_6 & = \\cos(x^2 + 2) \\cdot e^{- \\frac{x^2}{2}} \\\\\ny & = f(x) = \\cos(x^2 + 2) \\cdot e^{- \\frac{x^2}{2}} + \\frac{1}{x} \\\\\n\\end{flalign}\n$$\n\n:::\n\n:::{#exr-FunToGraphProg}\n\n## Funktion in Graph und Programm übersetzen\n<br>\n\nSchreibe zur mathematischen Funktion $y = f(x) = \\frac{\\ln(x^2 + 1)}{\\sqrt{x^2 + 1 + x}}$ den Ausdrucksbaum auf.\nÜbersetze den Ausdruck anschliessend in eine Python-Funktion gemäss der Konvention.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n```{dot}\n//| label: fig-compTreeSimple\n//| fig-cap: Computational Graph zum Ausdruck `y = ln(x^2 + 1) / sqrt(x^2 + 1 + x)`.\ndigraph \"\" {\n    rankdir=LR\n    fontname=\"Consolas\"\n    node [fontname=\"Consolas\", fontsize=8, width=\".2\", height=\".2\", margin=.02]\n    edge [fontname=\"Consolas\", fontsize=8, arrowsize=0.5, len=minlen]\n    graph[fontsize=8];\n\n\n    nx [label = \"x\", shape = none];\n    n2 [label = \"2\", shape = none];\n    n1 [label = \"1\", shape = none];\n    nPlus1 [label = \"+\", shape = circle];\n    nPlus2 [label = \"+\", shape = circle];\n    nPow [label = \"^\", shape = circle];\n    nFrac [label = \"/\", shape = circle];\n    nLog [label = \"ln( )\", shape = circle];\n    nSqrt [label = \"sqrt( )\", shape = circle];\n    ny [label = \"y\", shape = none];\n\n    nx -> nPow;\n    n2 -> nPow;\n    nPow -> nPlus1;\n    n1 -> nPlus1;\n    nx -> nPlus2;\n    nPlus1 -> nPlus2;\n    nPlus1 -> nLog;\n    nPlus2 -> nSqrt;\n    nLog -> nFrac;\n    nSqrt -> nFrac;\n    nFrac -> ny;\n}\n```\n\n```{python}\n#| eval: false\nimport math\n\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2\n    v2 = v1 + 1\n    v3 = v2 + v0\n    v4 = math.log(v2)\n    v5 = math.sqrt(v3)\n    y = v4 / v5\n    return y\n```\n:::\n\n:::{#exr-LoopProgToFun}\n\n## Ein Programm mit einer Schleife\n<br>\n\nErsetze im Funktionskörper die Schleife durch mehrere Befehle, so dass immer noch der gleiche mathematische Ausdruck berechnet wird und unsere Konvention eingehalten wird. Welche mathematische Funktion wird durch die Python-Funktion berechnet?\nWas ändert sich, wenn stattdessen `for i in range(3)` oder `for i in range(4)` stehen würde? \n\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    for i in range(2):\n        v0 = v0 ** 2 + 1\n    y = v0\n    return y\n```\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\nFür jeden Schleifendurchgang benötigen wir eine neue Hilfsvariable.\n\n::::{.panel-tabset}\n\n## `range(2)`\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2 + 1\n    v2 = v1 ** 2 + 1\n    y = v2\n    return y\n```\n$f(x) = (x^2 + 1)^2 + 1 = x^4 + 2x^2 + 2$\n\n\n## `range(3)`\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2 + 1\n    v2 = v1 ** 2 + 1\n    v3 = v2 ** 2 + 1\n    y = v3\n    return y\n```\n$f(x) = ((x^2 + 1)^2 + 1)^2 + 1 = x^8 + 4x^6 + 8x^4 + 8x^2 + 5$\n\n## `range(4)`\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2 + 1\n    v2 = v1 ** 2 + 1\n    v3 = v2 ** 2 + 1\n    v4 = v3 ** 2 + 1\n    y = v4\n    return y\n```\n$$\n\\begin{flalign}\n    f(x) &= (((x^2 + 1)^2 + 1)^2 + 1)^2 + 1 \\\\\n         &= x^{16} + 8x^{14} + 32x^{12} + 80x^{10} + 138x^8 + 168x^6 + 144x^4 + 80x^2 + 26\n\\end{flalign}\n$$\n\n::::\n\n:::\n\n\n\n## Unser Ziel: Programme ableiten\n\nWie eingangs erwähnt wurde, haben Ableitungen viele nützliche Anwendungen. \n\nCOMING SOON: Idee Programm als Funktion ableiten, Namensgebung AD, möglichst exakte Werte gesucht.\n\n\n### Das Newtonverfahren zur Berechnung von Nullstellen\n\nIn vielen Anwendungen steht man vor der Aufgabe, die Gleichung $f(x) = 0$ nach $x$ aufzulösen, d.h. eine Nullstelle der Funktion zu finden. Oft ist es aber nicht möglich, die Lösung einer solchen Gleichung in geschlossener Form darzustellen. Um dennoch eine Lösung zumindest näherungsweise berechnen zu können, kann man folgendermassen vorgehen:\n\n1. Wähle einen Startwert $x_0$, der in der Nähe einer Nullstelle $\\bar{x}$ von $f$ liegt.\n2. Im Kurvenpunkt $(x_0 | y_0)$ wird die Tangente an die Kurve $f$ gelegt. Deren Schnittpunkt $x_1$ mit der $x$-Achse liegt in der Regel näher bei $\\bar{x}$ als $x_0$.\n3. Nun wiederholt man das Verfahren, indem man bei $x_1$ die Tangente an die Kurve legt, usw. Auf diese Weise erhält man eine Folge von Näherungen $x_0, x_1, x_2, \\ldots$, deren Grenzwert die Nullstelle $\\bar{x}$ ist.\n\n:::{.fig-NewtonGeoGebra}\n\n<iframe scrolling=\"no\" title=\"Newtonverfahren\" src=\"https://www.geogebra.org/material/iframe/id/baja85gv/width/700/height/500/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/true/rc/false/ld/false/sdz/true/ctl/false\" width=\"700px\" height=\"500px\" style=\"border:0px;\"> </iframe>\n\n:::\n\nDie Gleichung der Tangente im Punkt $(x_n | y_n) = (x_n | f(x_n))$ ist bekanntlich $t(x) = f(x_n) + f'(x_n) \\cdot (x - x_n)$. Die Nullstelle der Tangente ist der Näherungswert $x_{n+1}$. Aus $t(x_{n+1}) = 0$ ergibt sich nun \n$$\nx_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\n$$\n\n:::{#exr-NewtonFirstTry}\n\n## Das Newtonverfahren programmieren\n<br>\n\nSchreibe ein Programm, das mit Hilfe des Newtonverfahrens eine Nullstelle der Funktion $f(x) = \\frac{1}{31} x^3 -\\frac{1}{20} x^2 -x + 1$ berechnet. Verwende den Startwert $x_0 = -2$. Du kannst abbrechen, wenn die Differenz $|x_{n+1} - x_n|$ kleiner als eine bestimmte Toleranz wird, u.B. kleiner als `tol = 1e-6`.\nWie flexibel ist dein Programm einsetzbar? Überlege dir z.B., wie viele Änderungen du vornehmen müsstest, wenn du die Nullstelle einer anderen Funktion berechnen müsstest. \n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\nWelche der folgenden Lösungsvorschläge kommt deinem Programm am nächsten?\n\n::::{.panel-tabset}\n\n## Newton als main-Programm (1)\n```{python}\n#| eval: true\n#| code-fold: false\nfrom math import fabs\n\nx0 = -2\ntol = 1e-6\n# Erster Schritt berechnen\nx1 = x0 - (1/31 * x0**3 - 1/20 * x0**2 - x0 + 1) / (3/31 * x0**2 - 1/10 * x0 - 1)\nwhile fabs(x1 - x0) > tol:\n    x0 = x1\n    x1 = x0 - (1/31 * x0**3 - 1/20 * x0**2 - x0 + 1) / (3/31 * x0**2 - 1/10 * x0 - 1)\nprint(x1)\n```\nDas Newtonverfahren wird als main-Funktion (d.h. im Hauptprogramm) ausgeführt. Braucht man jedoch die Nullstelle einer anderen Funktion, dann muss ein neues Programm geschrieben werden. Die Ableitung wurde von Hand berechnet.\n\n\n## Newton als main-Programm (2)\n```{python}\n#| eval: true\n#| code-fold: false\nfrom math import fabs\n\ndef f(x):\n    y = 1/31 * x**3 - 1/20 * x**2 - x + 1\n    return y\n\ndef fdot(x):\n    y = 3/31 * x**2 - 1/10 * x - 1\n    return y\n\nx0 = -2\ntol = 1e-6\n# Erster Schritt berechnen\nx1 = x0 - f(x0) / fdot(x0)\nwhile fabs(x1 - x0) > tol:\n    x0 = x1\n    x1 = x0 - f(x0) / fdot(x0)\nprint(x1)\n```\nDas Newtonverfahren wird als main-Funktion (d.h. im Hauptprogramm) ausgeführt, aber die Berechnung von $f$ und ihrer Ableitung $f'$ wurde in zwei Funktionen `f` und `fdot` ausgelagert. Das macht das Programm übersichtlicher und flexibler. Die Ableitung wurde wieder von Hand berechnet.\n\n## Newton als Funktion (1)\n```{python}\n#| eval: true\n#| code-fold: false\nfrom math import fabs\n\ndef newton(f, fdot, x0):\n    tol = 1e-6\n    # Erster Schritt berechnen\n    x1 = x0 - f(x0) / fdot(x0)\n    while fabs(x1 - x0) > tol:\n        x0 = x1\n        x1 = x0 - f(x0) / fdot(x0)\n    return(x1)\n\ndef f(x):\n    y = 1/31 * x**3 - 1/20 * x**2 - x + 1\n    return y\n\ndef fdot(x):\n    y = 3/31 * x**2 - 1/10 * x - 1\n    return y\n\nx0 = -2\nxbar = newton(f, fdot, x0)\nprint(xbar)\n```\nDas Newtonverfahren wird als eigene Funktion implementiert, der die Funktion $f$ und ihre Ableitung $f'$, sowie der Startwert $x_0$ als Argumente übergeben werden. Diese Funktion kann dann im Hauptprogramm aufgerufen werden. Die Ableitung wurde aber immer noch von Hand berechnet.\n\n## Newton als Funktion (2)\n```{python}\n#| eval: true\n#| code-fold: false\nfrom math import fabs\n\ndef newton(f, x0):\n    tol = 1e-6\n    # Erster Schritt berechnen\n    # Ableitung von f an der Stelle x0 annähern\n    h = 1e-6\n    ydot = ( f(x0 + h) - f(x0) ) / h\n    x1 = x0 - f(x0) / ydot\n    while fabs(x1 - x0) > tol:\n        x0 = x1\n        ydot = ( f(x0 + h) - f(x0) ) / h\n        x1 = x0 - f(x0) / ydot\n    return(x1)\n\ndef f(x):\n    y = 1/31 * x**3 - 1/20 * x**2 - x + 1\n    return y\n\nx0 = -2\nxbar = newton(f, x0)\nprint(xbar)\n```\nHier wird das Newtonverfahren in einer Funktion implementiert. Die Ableitung wird nicht mehr von Hand berechnet, sondern innerhalb der Funktion mit $f'(x_0)\\approx \\frac{f(x_0 + h) - f(x_0)}{h}$ angenähert. Dabei wird einfach `h = 1e-6` gesetzt und gehofft, dass der entstehende Rundungsfehler klein genug ist.\n\n\n::::\n\n:::\n\nAuch die letzte vorgestellte Lösung ist noch nicht befriedigend. Als wir die Ableitung von Hand berechnet hatten, musste nur die Funktion `fdot` and der Stelle `x0` ausgewertet werden, um den (bis auf Maschinengenauigkeit) *exakten* Wert von $f'(x_0)$ zu erhalten. Bei der letzten Methode muss man sich mit einem Näherungswert der Ableitung zufrieden geben. Auch wenn der Wert in diesem Beispiel gut genug war[^1], so haben wir doch keine Garantie, dass wir für alle Funktionen einen vernünftigen Wert erhalten. Auf die Probleme, die mit dieser Annäherung von $f'(x_0)$ auftreten, wird in @sec-ADnotNumDiff näher eingegangen.\n\n[^1]: Das Newton-Verfahren hat die angenehme Eigenschaft, dass kleine Rundungsfehler automatisch ausgeglichen werden. Auf andere numerische Verfahren, die die Ableitung verwenden, trifft dies aber nicht zu.\n\n### Gradient Descent zum Auffinden lokaler Minima\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","html-math-method":"mathjax","toc":true,"toc-depth":3,"reference-location":"margin","output-file":"intro.html"},"language":{},"metadata":{"lang":"de","fig-responsive":true,"quarto-version":"1.1.251","jupyter":"python3","bibliography":["references.bib"],"theme":"cosmo","code-copy":"hover","number-depth":3,"tbl-cap-location":"bottom"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"intro.pdf"},"language":{},"metadata":{"block-headings":true,"jupyter":"python3","bibliography":["references.bib"],"documentclass":"scrreprt","lang":"de","number-depth":3,"tbl-cap-location":"bottom"},"extensions":{"book":{}}}}}