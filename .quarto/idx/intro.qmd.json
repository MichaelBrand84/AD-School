{"title":"Ableitungen und ihre Anwendungen","markdown":{"yaml":{"tbl-cap-location":"bottom"},"headingText":"Ableitungen und ihre Anwendungen","containsRefs":false,"markdown":"\n\n\n\n## Ableitungen von Funktionen\n\nWir kennen Ableitungen von Funktionen $f: \\mathbb{R}\\rightarrow\\mathbb{R}$ aus dem Mathematikunterricht. Sie geben uns darüber Auskunft, wie gross die Steigung der Tangente in einem bestimmten Punkt des Funktionsgraphen ist. Die Tangente stellt dabei die beste lineare Annäherung an den Funktionsgraph dar. Ableitungen beschreiben auch die lokale Änderungsrate der Funktion. Ableitungen erlauben es uns ausserdem, die Extrema und Wendepunkte einer Funktion zu bestimmen. \n\nDie folgende Tabelle fasst die bekannten Ableitungen der Grundfunktionen zusammen.\n\n| $f(x)$                    | $f'(x)$                                 |     | $f(x)$                 | $f'(x)$                                 |\n|---------------------------|-----------------------------------------|-----|------------------------|-----------------------------------------|\n| $x^n$                     | $n \\cdot x^n \\quad (n\\in\\mathbb{R})$    |     | $\\sqrt{x}$             | $\\frac{1}{2\\cdot\\sqrt{x}}$              |\n| $e^x$                     | $e^x$                                   |     | $a^x$                  | $a^x \\cdot \\ln(a) \\quad (a>0, a\\ne 1)$  |\n| $\\ln(x)$                  | $\\frac{1}{x}$                           |     | $\\log_a(x)$            | $\\frac{1}{x\\cdot\\ln(a)}$                |\n| $\\sin(x)$                 | $\\cos(x)$                               |     | $\\arcsin(x)$           | $\\frac{1}{\\sqrt{1-x^2}}$                |\n| $\\cos(x)$                 | $-\\sin(x)$                              |     | $\\arccos(x)$           | $-\\frac{1}{sqrt{1-x^2}}$                |\n| $\\tan(x)$                 | $\\frac{1}{\\cos^2(x)} = 1 + \\tan^2(x)$   |     | $\\arctan(x)$           | $\\frac{1}{x^2+1}$                       |\n| $\\sinh(x)$                | $\\cosh(x)$                              |     | $\\textrm{arsinh}(x)$   | $\\frac{1}{\\sqrt{x^2+1}}$                |\n| $\\cosh(x)$                | $\\sinh(x)$                              |     | $\\textrm{arcosh(x)}$   | $\\frac{1}{\\sqrt{x^2-1}}$                |\n| $\\tanh(x)$                | $\\frac{1}{\\cosh^2(x)} = 1 - \\tanh^2(x)$ |     | $\\textrm{artanh(x)}$   | $-\\frac{1}{x^2-1}$                      |\n\n: Ableitungen der Grundfunktionen {#tbl-DiffGrundfunktionen}\n\nNeue Funktionen erhält man, indem man die Grundfunktionen aus @tbl-DiffGrundfunktionen addiert, subtrahiert, multipliziert, dividiert und komponiert, d.h. Verkettungen der Form $(f\\circ g)(x) = f(g(x))$ bildet. Um solche Funktionen abzuleiten brauchen wir die Regeln aus @tbl-DiffRegeln unten. Mit diesen Regeln sind wir dann schon in der Lage, alle differenzierbaren Funktionen abzuleiten.\n\n|     |     |\n| --- | --- |\n| Summenregel     | $\\frac{d}{dx}(f(x)\\pm g(x)) = f'(x) \\pm g'(x)$ |\n| Produktregel <br> *Spezialfall: Faktorregel*    | $\\frac{d}{dx}(f(x)\\cdot g(x)) = f'(x)\\cdot g(x) + f(x) \\cdot g'(x)$ <br> $\\frac{d}{dx}(a\\cdot f(x)) = a\\cdot f'(x)$ |\n| Quotientenregel | $\\frac{d}{dx}\\frac{f(x)}{g(x)} = \\frac{f'(x)\\cdot g(x) - f(x) \\cdot g'(x)}{g(x)^2}$  |\n| Kettenregel     | $\\frac{d}{dx} f(g(x)) = f'(g(x))\\cdot g'(x)$  |\n\n: Ableitungsregeln {#tbl-DiffRegeln}\n\nAn dieser Stelle sei noch angemerkt, dass sich der Begriff der Ableitung sinngemäss auf Funktionen $f: \\mathbb{R}^n \\rightarrow\\mathbb{R}^m$ verallgemeinern lässt. Eine kurze Beschreibung der Grundidee findet sich in @Slater2022. Weitergehende Informationen findet man z.B. in @Arens2022 oder jedem Lehrbuch zur Analysis 2.\n\n\n## Programme als Funktionen\n\nProgramme, die numerische Werte einlesen und numerische Werte ausgeben, können als mathematische Funktionen betrachtet werden. Wir beschränken uns zunächst auf Programme, die nur ein Argument erhalten und nur einen Rückgabewert liefern, z.B.\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    y = (2 + x) * (x - 3)\n    return y\n\nx0 = 2\nprint( f(x0) )\n```\n\nDiese Python-Funktion entspricht einer Funktion $f:\\mathbb{R}\\rightarrow\\mathbb{R}$ im Sinne der Mathematik. Natürlich kann der Funktionskörper viel komplizierter aufgebaut sein und z.B. Schleifen und Bedingungen enthalten. \n\nUm zu verstehen, wie der Computer einen Ausdruck wie `y = (2 + x) * (x - 3)` auswertet, ist es hilfreich, ihn als Baum (im Sinne der Graphentheorie) darzustellen. Ausdrucksbäume werden z.B. in @Hromkovic2021 erklärt.\n\n```{dot}\n//| label: fig-compTreeSimple\n//| fig-cap: Ausdrucksbaum zum Ausdruck `y = (2 + x) * (x - 3)`.\ndigraph \"\" {\n    rankdir=BT\n    fontname=\"Consolas\"\n    node [fontname=\"Consolas\", fontsize=8, width=\".2\", height=\".2\", margin=.02]\n    edge [fontname=\"Consolas\", fontsize=8, arrowsize=0.5, len=minlen]\n    graph[fontsize=8];\n\n\n    nx [label = \"x\", shape = none];\n    n2 [label = \"2\", shape = none];\n    n3 [label = \"3\", shape = none];\n    nPlus [label = \"+\", shape = circle];\n    nMinus [label = \"-\", shape = circle];\n    nMult [label = \"*\", shape = circle];\n    ny [label = \"y\", shape = none];\n\n    n2 -> nPlus;\n    nx -> nPlus;\n    nx -> nMinus;\n    n3 -> nMinus;\n    nPlus -> nMult;\n    nMinus -> nMult;\n    nMult -> ny;\n\n}\n```\n\nWir wollen nun unsere Python-Funktion so umschreiben, dass diese Struktur auch im Funktionskörper sichtbar wird. Dazu führen wir drei Hilfsvariablen `v0, v1, v2` ein.\n\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    v1 = 2 + v0\n    v2 = v0 - 3\n    y = v1 * v2\n    return y\n```\n\n:::{.callout-important}\n\n## Konvention\n\nEine Funktion berechnet aus einem Argument `x` einen Rückgabewert `y` über eine Reihe von Hilfsvariablen `v`, die mit verschiedenen Indizes versehen sind. Dabei setzen wir am Anfang immer `v0 = x`.\n\n:::\n\n:::{#exr-ProgToFun}\n\n## Programm in Funktion übersetzen\n  \nSchreibe die mathematische Funktion auf, die durch das folgende Programm berechnet wird.\n```{python}\n#| eval: false\n#| code-fold: false\nimport math\n\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2\n    v2 = v1 + 2\n    v3 = -v1 / 2\n    v4 = math.cos(v2)\n    v5 = math.exp(v3)\n    v6 = v4 * v5\n    y = v6 + 1 / v0\n    return y \n```\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n$$\n\\begin{flalign}\nv_1 & = x^2 \\\\\nv_2 & = x^2 + 2 \\\\\nv_3 & = - \\frac{x^2}{2} \\\\\nv_4 & = \\cos(x^2 + 2) \\\\\nv_5 & = e^{- \\frac{x^2}{2}} \\\\\nv_6 & = \\cos(x^2 + 2) \\cdot e^{- \\frac{x^2}{2}} \\\\\ny & = f(x) = \\cos(x^2 + 2) \\cdot e^{- \\frac{x^2}{2}} + \\frac{1}{x} \\\\\n\\end{flalign}\n$$\n\n:::\n\n:::{#exr-FunToGraphProg}\n\n## Funktion in Graph und Programm übersetzen\n  \nSchreibe zur mathematischen Funktion $y = f(x) = \\frac{\\ln(x^2 + 1)}{\\sqrt{x^2 + 1 + x}}$ den Ausdrucksbaum auf.\nÜbersetze den Ausdruck anschliessend in eine Python-Funktion gemäss der Konvention.\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\n```{dot}\n//| label: fig-compTreeSimple\n//| fig-cap: Ausdrucksbaum zum Ausdruck `y = ln(x^2 + 1) / sqrt(x^2 + 1 + x)`.\ndigraph \"\" {\n    rankdir=LR\n    fontname=\"Consolas\"\n    node [fontname=\"Consolas\", fontsize=8, width=\".2\", height=\".2\", margin=.02]\n    edge [fontname=\"Consolas\", fontsize=8, arrowsize=0.5, len=minlen]\n    graph[fontsize=8];\n\n\n    nx [label = \"x\", shape = none];\n    n2 [label = \"2\", shape = none];\n    n1 [label = \"1\", shape = none];\n    nPlus1 [label = \"+\", shape = circle];\n    nPlus2 [label = \"+\", shape = circle];\n    nPow [label = \"^\", shape = circle];\n    nFrac [label = \"/\", shape = circle];\n    nLog [label = \"ln( )\", shape = circle];\n    nSqrt [label = \"sqrt( )\", shape = circle];\n    ny [label = \"y\", shape = none];\n\n    nx -> nPow;\n    n2 -> nPow;\n    nPow -> nPlus1;\n    n1 -> nPlus1;\n    nx -> nPlus2;\n    nPlus1 -> nPlus2;\n    nPlus1 -> nLog;\n    nPlus2 -> nSqrt;\n    nLog -> nFrac;\n    nSqrt -> nFrac;\n    nFrac -> ny;\n}\n```\n\n```{python}\n#| eval: false\nimport math\n\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2\n    v2 = v1 + 1\n    v3 = v2 + v0\n    v4 = math.log(v2)\n    v5 = math.sqrt(v3)\n    y = v4 / v5\n    return y\n```\n:::\n\n:::{#exr-LoopProgToFun}\n\n## Ein Programm mit einer Schleife\n\nErsetze im Funktionskörper die Schleife durch mehrere Befehle, so dass immer noch der gleiche mathematische Ausdruck berechnet wird und unsere Konvention eingehalten wird. Welche mathematische Funktion wird durch die Python-Funktion berechnet?\nWas ändert sich, wenn stattdessen `for i in range(3)` oder `for i in range(4)` stehen würde? \n\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    for i in range(2):\n        v0 = v0 ** 2 + 1\n    y = v0\n    return y\n```\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Lösung\n\nFür jeden Schleifendurchgang benötigen wir eine neue Hilfsvariable.\n\n::::{.panel-tabset}\n\n## `range(2)`\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2 + 1\n    v2 = v1 ** 2 + 1\n    y = v2\n    return y\n```\n$f(x) = (x^2 + 1)^2 + 1 = x^4 + 2x^2 + 2$\n\n\n## `range(3)`\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2 + 1\n    v2 = v1 ** 2 + 1\n    v3 = v2 ** 2 + 1\n    y = v3\n    return y\n```\n$f(x) = ((x^2 + 1)^2 + 1)^2 + 1 = x^8 + 4x^6 + 8x^4 + 8x^2 + 5$\n\n## `range(4)`\n```{python}\n#| eval: false\n#| code-fold: false\ndef f(x):\n    v0 = x\n    v1 = v0 ** 2 + 1\n    v2 = v1 ** 2 + 1\n    v3 = v2 ** 2 + 1\n    v4 = v3 ** 2 + 1\n    y = v4\n    return y\n```\n$$\n\\begin{flalign}\n    f(x) &= (((x^2 + 1)^2 + 1)^2 + 1)^2 + 1 \\\\\n         &= x^{16} + 8x^{14} + 32x^{12} + 80x^{10} + 138x^8 + 168x^6 + 144x^4 + 80x^2 + 26\n\\end{flalign}\n$$\n\n::::\n\n:::\n\n\n\n## Unser Ziel: Programme ableiten\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","html-math-method":"mathjax","toc":true,"toc-depth":3,"output-file":"intro.html"},"language":{},"metadata":{"lang":"de","fig-responsive":true,"quarto-version":"1.1.251","jupyter":"python3","bibliography":["references.bib"],"theme":"cosmo","code-copy":"hover","number-depth":3,"tbl-cap-location":"bottom"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"intro.pdf"},"language":{},"metadata":{"block-headings":true,"jupyter":"python3","bibliography":["references.bib"],"documentclass":"scrreprt","lang":"de","number-depth":3,"tbl-cap-location":"bottom"},"extensions":{"book":{}}}}}